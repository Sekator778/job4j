## GC&JMM

+ [1. Стек и куча в Java](#1-Стек-и-куча-в-Java)
+ [2. Что такое менеджер памяти?](#2-Что-такое-менеджер-памяти?)
+ [3 Какой механизм используется в Java для управления памятью?](#3-Какой-механизм-используется-в-Java-для-управления-памятью?)
+ [4 Опишите процесс работы сборщика мусора?](#4-Опишите-процесс-работы-сборщика-мусора?)
+ [5 Какие алгоритмы сборщика вы знаете?]
+ [6 Чем отличаются сборщики мусора?]
+ [7 Расскажите про утилиты для анализа памяти?]
+ [8 Что такое ссылки?](#8-Что-такое-ссылки?)
+ [9 Какие типы ссылок вы знаете?](#9-Какие-типы-ссылок-вы-знаете?)
+ [10 Чем они отличаются?](#9-Какие-типы-ссылок-вы-знаете?)
+ [11 Расскажите про String pool, Int pool.](#11-Расскажите-про-String-pool,-Int-pool.)
+ [12 Расскажите о String.intern.](#12-Расскажите-о-String.intern.)
+ [13 Расскажите, что такое профайлер?]
+ [14 Расскажите, как использовать VisualVM.]
+ [15 Расскажите, чем отличается sampling от profiling? Это типы аудита. Режим работы в профайлере.]
+ [16 Расскажите о benchmark. Приведите примеры кода.]
+ [17 Расскажите о методы finalized.]
+ [18 Расскажите о методы clone? Deep clone and shallow clone.]
+ [13 Расскажите о Stack, Heap.]

 Чем java отличается от с++?
 1. В Java единственным глобальным пространством имен является классовая иерархия. 
 В этом языке просто невозможно создать глобальную переменную, не принадлежащую ни одному из классов.
 
 2. В Java оператора goto нет. В ней есть зарезервированное ключевое слово goto
 
 3. Указатели или адреса в памяти - наиболее мощная и наиболее опасная черта C++.
 
 4. в Java нет функций malloc() , free(). Распределение памяти в С, а значит и в C++, 
 опирается на инь и янь ненадежного кода - на вызовы библиотечных функций malloc() и free().
 "Утечка памяти" (memory leak) приводит к постепенному замедлению работы программы по мере того, как системе виртуальной
  памяти приходится сбрасывать на диск неиспользуемые страницы с мусором. И, наконец, когда все системные ресурсы исчерпаны,
   программа неожиданно аварийно завершается, а вы начинаете ломать голову над этой проблемой. В C++ добавлены два оператора
    - new и delete, которые используются во многом аналогично функциям malloc() и free(). Программист по-прежнему 
    отвечает за то, чтобы каждый неиспользуемый объект, созданный с помощью оператора new, был уничтожен оператором delete.
  в Java нет функций malloc() , free(). Поскольку в ней каждая сложная структура данных - это объект, память под такие
  структуры резервируется в куче (heap) с помощью оператора new. Реальные адреса памяти, выделенные этому объекту, могут
   изменяться во время работы программы, но вам не нужно об этом беспокоиться. Вам даже не придется вызывать free ()
    или delete, поскольку Java - система с так называемым сборщиком мусора. Сборщик мусора запускается каждый раз, когда 
    система простаивает, либо когда Java не может удовлетворить запрос на выделение памяти.
    
 5. Хрупкие типы данных
    C++ получил в наследство от С все обычные типы данных последнего. Эти типы служат для представления целых и 
    вещественных чисел различных размеров и точности. К несчастью, реальный диапазон и точность этих типов колеблется 
    в зависимости от конкретной реализации транслятора. Поведение кода, который прекрасно транслируется и выполняется 
    на одной машине, может радикально отличаться при смене платформы. Различные трансляторы C++ могут резервировать 
    под целый тип 16, 32 или 64 бита в зависимости от разрядности машинного слова.
        В Java эта проблема решена, поскольку, в ней для всех базовых числовых типов независимо используются определенные
         соглашения, не зависящие от конкретной реализации среды. Не исключено, что на некоторых 
     архитектурах реализовать работу с числами таких размеров в интерпретаторе Java окажется трудно, либо реализация будет 
     неэффективна, однако это единственный способ гарантировать воспроизводимые результаты на широком спектре платформ.
     
 6. Ненадежное приведение типов
    Приведение типов в С и C++ - мощный механизм, который позволяет произвольным образом изменять тип указателей. 
    Такой техникой надо пользоваться с крайней осторожностью, поскольку в С и С++ не предусмотрено средств, позволяющих 
    обнаруживать неправильное использование приведения типов. Поскольку объекты в C++ - это просто указатели на адреса памяти,
     в этом языке во время исполнения программы нет способа обнаруживать случаи приведения к несовместимым типам.
        Дескрипторы объектов в Java включают в себя полную информацию о классе, представителем которого является объект,
     так что Java может выполнять проверку совместимости типов на фазе исполнения кода, возбуждая исключение в случае ошибки.
 7. Ненадежные структуры
    С++ пытается предоставить программисту возможность инкапсуляции данных посредством объявления структур (struct)
     и полиморфизм с помощью объединений (union). Эти две конструкции прикрывают критические и катастрофические 
     машинно-зависимые ограничения по размеру и выравниванию данных.
        В Java нет конструкций struct и union, все это объединено в концепции классов.

## 2 Что такое менеджер памяти?
## 3 Какой механизм используется в Java для управления памятью?
## 4 Опишите процесс работы сборщика мусора?
## 5 Какие алгоритмы сборщика вы знаете?
## 6 Чем отличаются сборщики мусора?
## 7 Расскажите про утилиты для анализа памяти?
## 8 Что такое ссылки?
Ссылки в Java — указатели на объекты. Другими словами, ссылка — это переменная, содержащая адрес ячейки памяти, 
в которой хранится объект. Кроме того, ссылка может быть инициализирована как null — нулевая ссылка, не указывающая ни 
на какой объект в памяти (именно это значение является значением по умолчанию). Внутри класса в нестатическом контексте 
также может быть использована ссылка this, указывающая на текущий объект, и ссылка super, указывающая на текущий объект
 суперкласса.)
## 9 Какие типы ссылок вы знаете?
В Java различают переменные примитивного и ссылочного типа. К примитивным относят 8 типов — пять целочисленных,
 два для чисел с плавающей точкой и логический тип boolean. Все остальные типы данных относятся к ссылочным типам. 
 Это значит, что объявленная переменная этого типа хранит не состояние объекта, а ссылку на него, сам же объект хранится
  в определённой области памяти (куче). Создание нового класса, абстрактного класса, интерфейса или перечисления
   равносильно определению нового ссылочного типа данных. В отличие от создания объектов, объявление ссылок типа
    абстрактный класс либо интерфейс не запрещено.
    Ссылка
    Абстрактный класс java.lang.ref.Reference[7] предоставляет базу для ссылочных классов. В нём определены следующие методы:
    
    get — метод, возвращающий сильную ссылку на объект, на который указывает ссылка.
    clear — очищает ссылку.
    isEnqueued и enqueue, отвечающие за взаимодействие ссылки и объекта ReferenceQueue.
##Мягкая ссылка
Мягкая ссылка — объект класса java.lang.ref.SoftReference. Особенность такой ссылки в том, что если она указывает на 
объект, на который не указывают сильные ссылки, этот объект может быть удалён сборщиком мусора в случае угрозы OutOfMemoryError.
Несколько примеров использования мягких ссылок:
Кэширование. В частности, этот подход использован в классе java.lang.Class — информация о полях, конструкторах и методах класса закэширована с помощью мягких ссылок.
Защита от OutOfMemoryError при получении потенциально огромного количества информации. В этом случае данные всё равно не будут обработаны, но вовремя удалённый объект позволит серверу продолжить работу в штатном режиме, тогда как системная ошибка нехватка памяти может дестабилизровать работу других Java-приложений на этом сервере.[9]
Объявление мягкой ссылки:
SoftReference<Thing> thing = new SoftReference<Thing>(new Thing()); //мягкая ссылка на объект класса Thing
##Слабая ссылка
Слабая ссылка — объект класса java.lang.ref.WeakReference. Особенность такой ссылки в том, что если она указывает на объект,
 на который не указывают сильные и мягкие ссылки, этот объект может быть удалён сборщиком мусора.

Несколько примеров использования слабых ссылок:

Ассоциация объектов. Например, имеется множество объектов Action, каждый из которых создаётся, запускаем на выполнение
 некоторую логику и после того, как она отработает, более не нужен. Пусть для каждого такого объекта создаётся уникальная 
 строка-идентификатор. Сопоставить идентификатор и Action можно с помощью ассоциативного массива (Map). В этом случае в 
 массиве будет храниться сильная ссылка на каждый Action, а значит, они не будут удаляться из памяти. Чтобы избежать этого,
  можно хранить в Map слабые ссылки на Action. Как только Action завершит работу и на него пропадут сильные ссылки, он будет удалён;
   до тех же пор к нему можно будет обращаться по сопоставленному идентификатору.
WeakHashMap — представитель Java Collections Framework, в основе которого лежат слабые ссылки. В отличие от описанного выше
 подхода, хранит слабые ссылки на ключи. Когда на ключ не остаётся сильных ссылок, он удаляется сборщиком мусора, затем с
  помощью ReferenceQueue определяется, какой ключ был удалён. Соответствующее ему значение также удаляется.
С помощью слабых ссылок можно обеспечить отсутствие дублирующихся объектов: в классе создаётся пул слабых ссылок на объекты
 и реализуется метод intern() (по аналогии с одноименным методом в классе java.lang.String). Вызванный на объекте, этот 
 метод либо вернёт ссылку на объект из пула, если в нём хранится объект, равный данному, либо поместит этот объект в пул.
##Фантомная ссылка
Фантомная ссылка — объект класса java.lang.ref.PhantomReference. Объект, на который существуют только фантомные ссылки,
 доступен сборщику мусора. В отличие от описанных выше типов ссылок, фантомная ссылка не даёт пользователю возможности 
 «спасти» объект, создав на него сильную ссылку: метод get на ней всегда возвращает null.

Зато с помощью фантомной ссылки можно определить, что объект собирается быть удалён. В силу этих особенностей фантомная
 ссылка бесполезна без объекта ReferenceQueue, поэтому для неё определён единственный конструктор:

ReferenceQueue<Wiki> queue = new ReferenceQueue<Wiki>(); //создание очереди 
PhantomReference<Wiki> ref = new PhantomReference<Wiki>(new Wiki("cyclowiki.org"), queue);
Основное предназначение фантомных ссылок — замена методу finalize, имеющему большое количество недостатков.[10] С 
их помощью можно реализовать логику подготовки объекта к удалению, например освобождение захваченных им ресурсов,
 очистка сессии, сохранение состояния или логгирование. Фантомная ссылка, указывающая на удаляемый объект, попадает
  в ReferenceQueue, откуда она может быть извлечена. Поскольку базовая фантомная ссылка не предоставляет пользователю 
  возможности определить, на какой именно объект она ссылается, стоит реализовывать собственного потомка класса PhantomReference,
   хранящего идентификатор объекта (не ссылку на сам объект, ибо это будет сильная ссылка — объект перестанет быть доступен
    сборщику мусора). В таком случае после обращения к идентификатору можно однозначно определить, какой объект был удалён,
     и выполнить все необходимые операции.

## 11 Расскажите про String pool, Int pool.
Объект String является наиболее используемым классом в языке Java.
Благодаря неизменности Strings в Java, JVM может оптимизировать объем памяти, выделенный для них, сохраняя только одну 
копию каждого литерала String в пуле . Этот процесс называется interning 
String Pool - это область хранения в куче Java.

Распределение строк, как и все объекты , оказывается дорогостоящим делом как в отношении времени, так и памяти.
 JVM выполняет некоторые шаги при инициализации строковых литералов, чтобы повысить производительность и уменьшить 
 накладные расходы памяти. Чтобы уменьшить количество объектов String, созданных в JVM, класс String хранит пул строк.
 
Когда мы создаем переменную String и присваиваем ей значение, JVM ищет в пуле String с равным значением.
Если найден, компилятор Java просто возвратит ссылку на свой адрес памяти, без выделения дополнительной памяти. **
Если он не найден, он будет добавлен в пул (интернирован) и его ссылка будет возвращена.

Теперь я покажу вам реализацию и работу пула строк на примере.

Но перед этим короткое напоминание!

Как вы знаете, если вы сравниваете 2 объекта с помощью оператора ==, он сравнивает адреса в памяти.
public class StringPoolExperiment {
  
    public static void main(String[] args) {
        String s1 = "Rachel";
        String s2 = "Rachel";
        String s3 = new String("Rachel");
        String s4 = new String("Rachel").intern();
  
        System.out.println(s1 == s2); // true
        System.out.println(s1 == s3); // false
        System.out.println(s1 == s4); // true
    }
}
# Примечание о Java 9
До Java 8 строки представлялись в виде массива символов - char [] , закодированного в UTF-16 ,
 так что каждый символ использует два байта памяти.
В Java 9 представлено новое представление, называемое Compact Strings. Этот новый формат будет выбирать подходящую 
кодировку между char [] и byte [] в зависимости от сохраняемого содержимого.
Поскольку новое представление String будет использовать кодировку UTF-16 только при необходимости, объем памяти кучи 
будет значительно ниже, что, в свою очередь, приводит к меньшим издержкам сборщика мусора в JVM.

## 12 Расскажите о String.intern.
Метод intern () создает точную копию объекта String в памяти кучи и сохраняет ее в пуле констант String .
Обратите внимание, что если в пуле констант String существует другая строка с таким же содержимым , то новый объект
 не будет создан, а новая ссылка будет указывать на другую строку.
 
 @Test
 public void whenIntern_thenCorrect() {
     String s1 = "abc";
     String s2 = new String("abc");
     String s3 = new String("foo");
     String s4 = s1.intern();
     String s5 = s2.intern();
     assertFalse(s3 == s4);
     assertTrue(s1 == s5);
 }
 
## 13 Расскажите, что такое профайлер?
## 14 Расскажите, как использовать VisualVM.
## 15 Расскажите, чем отличается sampling от profiling? Это типы аудита. Режим работы в профайлере.
## 16 Расскажите о benchmark. Приведите примеры кода.
## 17 Расскажите о методы finalized.
## 18 Расскажите о методы clone? Deep clone and shallow clone.
## 13 Расскажите о Stack, Heap.


## 1 Стек и куча в Java

Для оптимальной работы приложения JVM делит память на область стека (stack) и область кучи (heap). Всякий раз,
когда мы объявляем новые переменные, создаем объекты или вызываем новый метод, JVM выделяет память для этих операций в стеке или в куче
тек работает по схеме LIFO (последним вошел, первым вышел). Всякий раз, когда вызывается новый метод, содержащий
 примитивные значения или ссылки на объекты, то на вершине стека под них выделяется блок памяти

Когда метод завершает выполнение, блок памяти, отведенный для его нужд, очищается, и пространство становится доступным для следующего метода
Основные особенности стека
Помимо того, что мы рассмотрели, существуют и другие особенности стека:
Он заполняется и освобождается по мере вызова и завершения новых методов
Переменные в стеке существуют до тех пор, пока выполняется метод в котором они были созданы
Если память стека будет заполнена, Java бросит исключение java.lang.StackOverFlowError
Доступ к этой области памяти осуществляется быстрее, чем к куче
является потокобезопасным, поскольку для каждого потока создается свой отдельный стек

2. Куча

Эта область памяти используется для объектов и классов. Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке

Эти объекты имеют глобальный доступ и могут быть получены из любого места программы
Эта область памяти разбита на несколько более мелких частей, называемых поколениями:
Young Generation — область где размещаются недавно созданные объекты. Когда она заполняется, происходит быстрая сборка мусора
Old (Tenured) Generation — здесь хранятся долгоживущие объекты. Когда объекты из Young Generation достигают
 определенного порога "возраста", они перемещаются в Old Generation
Permanent Generation — эта область содержит метаинформацию о классах и методах приложения, но начиная с Java 8
 данная область памяти была упразднена.
 
 
 
В Java -Xms установить начальный размер кучи Java,
     -Xmx установить максимальный размер кучи Java.
     пример
     # Start with 128MB of memory, and allow the Java process to use up to 1024MB of memory.
-->     java -Xms128m -Xmx1024m

Если процесс Java превысил -Xmx максимальный размер кучи Java,  java.lang.OutOfMemoryError будет брошен.
[к оглавлению](#GC&JMM)

java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal -version

Если параметр объявлен с "=" , то это значение по умолчанию.
Если с ":=" , то параметр был переопределен.

Полное описание всех параметров на сайте oracle.

Значения, выставляемые по умолчанию:
* Для серверного ПК:
- Parallel (Throutput) collector
- Xms (начальный размер Heap) = 1/64 доступной памяти
- Xmx (максимальный размер Heap) = 1/4 памяти
* Для прочих устройств:
- Serial gc
- Xm* параметры такиеже

Вариант оптимизации: устанавливать Xms = Xmx, чтобы ускорить работу программы, за счет уменьшения числа изменений объема памяти

Виды сборщиков мусора

Serial
-XX:+UseSerialGC
Используется в клиентских java машинах.
Обе области: yang и old работают в 1 поток
Вариант оптимизации - это множество независимых программ работающих параллельно на 1 машине.
В этом случае однопоточный gc создан меньше нагрузки, чем множество многопоточных

Parallel
-XX:+UseParallelGC
Yang GC работает в параллельном режиме
Olg GC по прежнему однопоточный
Число потоков задается параметром "-XX:ParallelGCThreads" - по умолчанию = числу ядер процессора. Если на машине запущенно множество программ, то число параллельных потоков можно снизить.
Подходит для серверных приложений, где важен объем обрабатываемых данных, а не скорость отклика, т.к. очистка происходит с остановкой основной программы.

G1
-XX:+UseG1GC
Этот коллектор используется по умолчанию в серверных приложениях.

По принципу работы G1 схож с CMS, но имеет ряд преимуществ:
* Выполняется конкурентно как CMS gc
* Память дефрагментируется без остановки основного цикла программы
* Фиксированный (предсказуемый) размер паузы gc
* Пропускная способность остается достаточно высокой
* Не требует дополнительных 20% озу, как CMS gc (но все равно нужны 10% = G1ReservePercent)

Достигается это за счет того, что вся память делится на 2048 регионов (-XX:G1HeapRegionSize) от 1 до 32 МБ (в зависимости от размера кучи).
Выжившие объекты копируются из своего региона в свободный (дефрагментация), этот процесс дискретный и может быть остановлен в любой момент (фиксированная пауза)
Желательно чтобы размер объекта был от 50-100% размера региона. Если объект больше региона, то он будет хранится в смежных регионах, что может вызывать задержки при обработке.

Параметры коллектора, на которые стоит обратить внимание:

-XX:MaxGCPauseMillis=200
Ставьте этот параметр = 90% от необходимого времени отклика

-XX:ConcGCThreads
кол-во процессов параллельной обработки регионов

-XX:InitiatingHeapOccupancyPercent=45
заполненность heap, после которой начинается gc

-XX:G1ReservePercent=10
резерв памяти, для защиты от переполнения

Типы ссылок в Java

