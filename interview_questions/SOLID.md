## SOLID

+ [Что такое SOLID?](#Что-такое-SOLID)
+ [Для чего используются JavaDoc?](#Для-чего-используются-JavaDoc)
+ [Как писать JavaDoc?](#Как-писать-JavaDoc)
+ [Что такое Java code convention?](#Что-такое-Java-code-convention)
+ [Расскажите про принципы составления Java класса.](#Расскажите-про-принципы-составления-Java-класса)
+ [Что такое SRP?](#Что-такое-SRP)
+ [Расскажите о нарушениях принципе SRP?](#Расскажите-о-нарушениях-принципе-SRP)
+ [Последствия нарушения SRP?](#Последствия-нарушения-SRP)
+ [Что такое OCP?](#Что-такое-OCP)
+ [Расскажите о нарушениях принципе OCP?](#Расскажите-о-нарушениях-принципе-OCP)
+ [Последствия нарушения OCP?](#Последствия-нарушения-OCP)
+ [Что такое LSP?](#Что-такое-LSP)
+ [Расскажите о нарушениях принципе LSP?](#Расскажите-о-нарушениях-принципе-LSP)
+ [Последствия нарушения LSP?](#Последствия-нарушения-LSP)
+ [Что такое ISP?](#Что-такое-ISP)
+ [Расскажите о нарушениях принципе ISP?](#Расскажите-о-нарушениях-принципе-ISP)
+ [Последствия нарушения ISP?](#Последствия-нарушения-ISP)
+ [Что такое DIP?](#Что-такое-DIP)
+ [Расскажите о нарушениях принципе DIP?](#Расскажите-о-нарушениях-принципе-DIP)
+ [Последствия нарушения DIP?](#Последствия-нарушения-DIP)
+ [Расскажите что такое автоматическое тестирование?](#Расскажите-что-такое-автоматическое-тестирование)
+ [Как в Java осуществляется автоматическое тестирование?](#Как-в-Java-осуществляется-автоматическое-тестирование)
+ [Что такое JUnit? Как использовать для тестирования?](#Что-такое-JUnit-Как-использовать-для-тестирования)
+ [Что такое функциональное тестирование чем отличается от модульного?](#Что-такое-функциональное-тестирование-чем-отличается-от-модульного)
+ [Расскажите про принцип TDD?](#Расскажите-про-принцип-TDD)
+ [Расскажите про принцип BDD?](#Расскажите-про-принцип-BDD)
+ [Что такое тестирование черным ящиком](#Что-такое-тестирование-черным-ящиком)


## Что такое SOLID

Что же такое SOLID-принципы? Это аббревиатура пяти основных принципов дизайна классов в объектно-ориентированном проектировании
  + Single responsibility, 
  + Open-closed, 
  + Liskov substitution, 
  + Interface segregation 
  + Dependency inversion
  
  SOLID принципы советуют, как проектировать модули, т.е. кирпичикам, из которых строится приложение. Цель принципов — проектировать модули, которые:   
  + способствуют изменениям
  + легко понимаемы
  + повторно используемы  

[к оглавлению](#SOLID)

## Для чего используются JavaDoc

Javadoc — генератор документации в HTML-формате из комментариев исходного кода на Java
Javadoc также предоставляет API для создания доклетов и тэглетов, которые позволяют программисту анализировать структуру Java-приложения.
В каждом случае комментарий должен находиться перед документируемым элементом.
@author, @version, @since
Многие IDE также используют Javadocs для генерации контекстных описаний API

[к оглавлению](#SOLID)

## Как писать JavaDoc

Утилита javadoc позволяет вставлять HTML тэги и использовать специальные ярлыки (дескрипторы) документирования. 
НТМL тэги заголовков не используют, чтобы не нарушать стиль файла, сформированного утилитой.
Дескрипторы javadoc, начинающиеся со знака @, называются автономными и должны помещаться с начала строки комментария (лидирующий символ * игнорируется). 
Дескрипторы, начинающиеся с фигурной скобки, например {@code}, называются встроенными и могут применяться внутри описания.

Комментарии документации применяют для документирования классов, интерфейсов, полей (переменных), конструкторов и методов. 
В каждом случае комментарий должен находиться перед документируемым элементом.

Документирование класса, метода или переменной начинается с комбинации символов /** , после которого следует тело комментариев; заканчивается комбинацией символов */.

В тело комментариев можно вставлять различные дескрипторы. Каждый дескриптор, начинающийся с символа '@' должен стоять первым в строке. 
Несколько дескрипторов одного и того же типа необходимо группировать вместе. 
Встроенные дескрипторы (начинаются с фигурной скобки) можно помещать внутри любого описания.

```java
/** 
 * Класс продукции со свойствами <b>maker</b> и <b>price</b>.
 * @autor Киса Воробьянинов
 * @version 2.1
*/
class Product
{
    /** Поле производитель */
    private String maker;

    /** Поле цена */
    public double price;

    /** 
     * Конструктор - создание нового объекта
     * @see Product#Product(String, double)
     */
    Product()
    {
        setMaker("");
        price=0;
    }

    /** 
     * Конструктор - создание нового объекта с определенными значениями
     * @param maker - производитель
     * @param price - цена
     * @see Product#Product()
     */
    Product(String maker,double price){
        this.setMaker(maker);
        this.price=price;
    }

    /**
     * Функция получения значения поля {@link Product#maker}
     * @return возвращает название производителя
     */
    public String getMaker() {
        return maker;
    }

   /**
     * Процедура определения производителя {@link Product#maker}
     * @param maker - производитель
     */
    public void setMaker(String maker) {
        this.maker = maker;
    }
}
```

[к оглавлению](#SOLID)

## Что такое Java code convention

Документ Oracle по правилам оформления кода.
Соглашения по офрмлению кода важны для программистов по ряду причин:

+ 80% от стоимости программного обеспечения приходится на его обслуживание.
+ Вряд ли какое-либо программное обеспечение все время поддерживается первоначальным разработчиком.
+ Соглашения по оформлению кода делают исходный код программ более удобочитаемым, позволяя инженерам более быстро и тщательно понимать новый код.
+ Если вы предоствляете исходный код как продукт, вы должны убедится, что он хорошо оформлен и упакован как любой другой продукт который вы создаете

[Code conventions](https://www.oracle.com/technetwork/java/codeconventions-150003.pdf)

[к оглавлению](#SOLID)

## Расскажите про принципы составления Java класса

+ **Принцип единственной ответственности (SRP).** Данный принцип гласит: никогда не должно быть больше одной причины изменить класс.
+ **Принцип открытости/закрытости (OCP)** программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.
+ **Принцип подстановки Барбары Лисков (LSP)** Это вариация принципа открытости/закрытости, о котором говорилось ранее. Его можно описать так: объекты в программе можно заменить их наследниками без изменения свойств программы.
+ **Принцип разделения интерфейса (ISP)** клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.
+ **Принцип инверсии зависимостей (DIP)** зависимости внутри системы строятся на основе абстракций

[к оглавлению](#SOLID)

## Что такое SRP

A module should be responsible to one, and only one, actor.
Старая формулировка: A module should have one, and only one, reason to change.

Часто ее трактовали следующим образом: Модуль должен иметь только одну обязанность. 
И это главное заблуждение при знакомстве с принципами. Все несколько хитрее.

На каждом проекте люди играют разные роли (actor): Аналитик, Проектировщик интерфейсов, Администратор баз данных. 
Естественно, один человек может играть сразу несколько ролей. 
В этом принципе речь идет о том, что изменения в модуле может запрашивать одна и только одна роль. 
Например, есть модуль, реализующий некую бизнес-логику, запросить изменения в этом модуле может только Аналитик, но никак не DBA или UX.

[к оглавлению](#SOLID)

## Расскажите о нарушениях принципе SRP

Например, рассмотрим этот код:

```java
class Animal {
    constructor(name: string){ }
    getAnimalName() { }
    saveAnimal(a: Animal) { }
}
```

Класс Animal, представленный здесь, описывает какое-то животное. Этот класс нарушает принцип единственной ответственности. 
Как именно нарушается этот принцип?

В соответствии с принципом единственной ответственности класс должен решать лишь какую-то одну задачу. 
Он же решает две, занимаясь работой с хранилищем данных в методе saveAnimal и манипулируя свойствами объекта в конструкторе и в методе getAnimalName.

Как такая структура класса может привести к проблемам?

Если изменится порядок работы с хранилищем данных, используемым приложением, то придётся вносить изменения во все классы, работающие с хранилищем. Такая архитектура не отличается гибкостью, изменения одних подсистем затрагивают другие, что напоминает эффект домино.

Для того чтобы привести вышеприведённый код в соответствие с принципом единственной ответственности, 
создадим ещё один класс, единственной задачей которого является работа с хранилищем, в частности — сохранение в нём объектов класса Animal:

```java
class Animal {
    constructor(name: string){ }
    getAnimalName() { }
}
class AnimalDB {
    getAnimal(a: Animal) { }
    saveAnimal(a: Animal) { }
}
```

[к оглавлению](#SOLID)

## Последствия нарушения SRP

Вместо изенения в одном месте, придется вносить одни и те же изменения в разных местах. Если где-то пропустить, это приведет к ошибке.

[к оглавлению](#SOLID)

## Что такое OCP

A software artifact should be open for extension but closed for modification.
Старая формулировка: You should be able to extend a classes behavior, without modifying it.

Это определенно может ввести в ступор. Как можно расширить поведение класса без его модификации? 
В текущей формулировке Роберт Мартин оперирует понятием артефакт, т.е. jar, dll, gem, npm package. 
Чтобы расширить поведение, нужно воспользоваться динамическим полиморфизмом.

Например, наше приложение должно отправлять уведомления. Используя dependency inversion, наш модуль объявляет только интерфейс отправки уведомлений, но не реализацию. 
Таким образом, логика нашего приложения содержится в одном dll файле, а класс отправки уведомлений, реализующий интерфейс — в другом. 
Таким образом, мы можем без изменения (перекомпиляции) модуля с логикой использовать различные способы отправки уведомлений.

Этот принцип тесно связан с LSP и DIP, которые мы рассмотрим далее.

[к оглавлению](#SOLID)

## Расскажите о нарушениях принципе OCP

Это означает, что должна быть возможность изменять внешнее поведение класса, не внося физические изменения в сам класс. 
Следуя этому принципу, классы разрабатываются так, чтобы для подстройки класса к конкретным условиям применения было достаточно расширить его и переопределить некоторые функции.

Рассмотри на примере класса OrderRepository.

```java
class OrderRepository
{
	public function load($orderID)
	{
		$pdo = new PDO($this->config->getDsn(), $this->config->getDBUser(), $this->config->getDBPassword());
		$statement = $pdo->prepare('SELECT * FROM `orders` WHERE id=:id');
		$statement->execute(array(':id' => $orderID));
		return $query->fetchObject('Order');	
	}
	public function save($order){/*...*/}
	public function update($order){/*...*/}
	public function delete($order){/*...*/}
}
```

В данном случае хранилищем у нас является база данных. например, MySQL. 
Но вдруг мы захотели подгружать наши данные о заказах, например, через API стороннего сервера, который, допустим, берёт данные из 1С. 
Какие изменения нам надо будет внести? Есть несколько вариантов, например, непосредственно изменить методы класса OrderRepository, 
но этот не соответствует принципу открытости/закрытости, так как класс закрыт для модификации, 
да и внесение изменений в уже хорошо работающий класс нежелательно. 
Значит, можно наследоваться от класса OrderRepository и переопределить все методы, но это решение не самое лучше, 
так как при добавлении метода в OrderRepository нам придётся добавить аналогичные методы во все его наследники. 
Поэтому для выполнения принципа открытости/закрытости лучше применить следующее решение — создать интерфейc IOrderSource, 
который будет реализовываться соответствующими классами MySQLOrderSource, ApiOrderSource и так далее.

[к оглавлению](#SOLID)

## Последствия нарушения OCP

Вместо изенения в одном месте, придется вносить одни и те же изменения в разных местах. Если где-то пропустить, это приведет к ошибке.

[к оглавлению](#SOLID)

## Что такое LSP

Имеет сложное математическое определение, которое можно заменить на: Функции, которые используют базовый тип, 
должны иметь возможность использовать подтипы базового типа, не зная об этом.

Классический пример нарушения. Есть базовый класс Stack, реализующий следующий интерфейс: length, push, pop. 
И есть потомок DoubleStack, который дублирует добавляемые элементы. Естественно, класс DoubleStack нельзя использовать вместо Stack.

У этого принципа есть забавное следствие: Объекты, моделирующие сущности, не обязаны реализовывать отношения этих сущностей. 
Например, у нас есть целые и вещественные числа, причем целые числа — подмножество вещественных. 
Однако, double состоит из двух int: мантисы и экспоненты. Если бы int наследовал от double, то получилась бы забавная картина: родитель содержит 2-х своих детей.

В качестве второго примера можно привести Generics. Допустим, есть базовый класс Shape и его потомки Circle и Rectangle. 
И есть некая функция Foo(List<Shape> list). Мы считаем, что List<Circle> можно привести к List<Shape>. 
Однако, это не так. Допустим, это приведение возможно, но тогда в list можно добавить любую фигуру, например rectangle. 
А изначально list должен содержать только объекты класса Circle.

[к оглавлению](#SOLID)

## Расскажите о нарушениях принципе LSP

Его можно описать так: объекты в программе можно заменить их наследниками без изменения свойств программы.
Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.
Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, 
чтобы не нарушалась функциональность с точки зрения клиента. 
То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов.

Предположим у нас есть класс, который отвечает за валидацию заказа и проверяет, все ли из товаров заказа находятся на складе. 
У данного класса есть метод isValid который возвращает true или false:

```java
public class OrderStockValidator {

    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if (! item.isInStock()) {
                return false;
            }
        }

        return true;
    }
}
```

Также предположим, что некоторые заказы нужно валидировать иначе: проверять, 
все ли товары заказа находятся на складе и все ли товары упакованы. 
Для этого мы расширили класс OrderStockValidator классом OrderStockAndPackValidator:

```java
public class OrderStockAndPackValidator extends OrderStockValidator {

    @Override
    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if ( !item.isInStock() || !item.isPacked() ){
                throw new IllegalStateException(
                     String.format("Order %d is not valid!", order.getId())
                );
            }
        }

        return true;
    }
}
```

Однако в данном классе мы нарушили принцип LSP, так как вместо того, чтобы вернуть false, если заказ не прошел валидацию, 
наш метод бросает исключение IllegalStateException. Клиенты данного кода не рассчитывают на такое: они ожидают возвращения true или false. 
Это может привести к ошибкам в работе программы.

[к оглавлению](#SOLID)

## Последствия нарушения LSP

Неожиданное поведение классов. Ошибки в программе при замене на подклассы.

[к оглавлению](#SOLID)

## Что такое ISP

Make fine grained interfaces that are client specific.

Под интерфейсом здесь понимается именно Java, C# интерфейс. Разделение интерфейса облегчает использование и тестирование модулей.
Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. 
Клиенты не должны зависеть от интерфейсов, которые они не используют.

[к оглавлению](#SOLID)

## Расскажите о нарушениях принципе ISP

Характеризуется следующим утверждением: клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.
Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.

[к оглавлению](#SOLID)

## Последствия нарушения ISP

Рассмотрим пример. Разработчик Алекс создал интерфейс "отчет" и добавил два метода: generateExcel() и generatedPdf(). 
Теперь клиент А хочет использовать этот интерфейс, но он намерен использовать отчеты только в PDF-формате, а не в Excel. 
Устроит ли его такая функциональность?

Нет. Он должен будет реализовать два метода, один из которых по большому счету не нужен и существует только благодаря Алексу — дизайнеру программного обеспечения. 
Клиент воспользуется либо другим интерфейсом, либо оставит поле для Excel пустым.

Так в чем же решение? Оно состоит в разделении существующего интерфейса на два более мелких. 
Один — отчет в формате PDF, второй — отчет в формате Excel. Это даст пользователю возможность использовать только необходимый для него функционал.

[к оглавлению](#SOLID)

## Что такое DIP

Depend on abstractions, not on concretions.

Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Что такое модули верхних уровней? Как определить этот уровень? Как оказалось, все очень просто. 
Чем ближе модуль к вводу/выводу, тем ниже уровень модуля. Т.е. модули, работающие с BD, интерфейсом пользователя, низкого уровня. 
А модули, реализующие бизнес-логику — высокого уровня.

Что такое зависимость модулей? Это ссылка на модуль в исходном коде, т.е. import, require и т.п. 
С помощью динамического полиморфизма в runtime можно обратить эту зависимость.

Есть модуль Logic, реализующий логику, который должен отсылать уведомления. 
В этом же пакете объявляется интерфейс ISender, который используется Logic. 
Уровнем ниже, в другом пакете объявляется ConcreteSender, реализующий ISender. 
Получается, что в момент компиляции Logic не зависит от ConcreteSender. 
В runtime, например, через конструктор в Logic устанавливается экземпляр ConcreteSender.

Отдельно стоит отметить частый вопрос “Зачем плодить абстракции, если мы не собираемся заменять базу данных?”.
Логика тут следующая. На старте проекта, мы знаем, что будем использовать реляционную базу данных, и это точно будет Postgresql, 
а для поиска — ElasticSearch. Мы даже не планируем их менять в будущем. Но мы хотим отложить принятие решений о том, 
какая будет схема таблиц, какие будут индексы, и т.п. до момента, пока это не станет проблемой. 
И на этот момент мы будем обладать достаточной информацией, чтобы принять правильное решение. 
Также мы можем раньше отладить логику нашего приложения, реализовать интерфейс, собрать обратную связь от заказчика, 
и минимизировать последующие изменения, ведь многое реализовано только в виде заглушек.

[к оглавлению](#SOLID)

## Расскажите о нарушениях принципе DIP

Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись друг с другом с помощью абстракции.

Попробуем продемонстрировать это на примере. Говоря о принципе единственной ответственности, мы рассматривали некоторый OrderProcessor. 
Взглянем еще раз на код данного класса: 

```java
public class OrderProcessor {
    public void process(Order order){

        MySQLOrderRepository repository = new MySQLOrderRepository();
        ConfirmationEmailSender mailSender = new ConfirmationEmailSender();

        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }

}
``` 

В данном примере наш OrderProcessor зависит от двух конкретных классов MySQLOrderRepository и ConfirmationEmailSender

Правильный вариант:

```java
public class OrderProcessor {

    private MailSender mailSender;
    private OrderRepository repository;

    public OrderProcessor(MailSender mailSender, OrderRepository repository) {
        this.mailSender = mailSender;
        this.repository = repository;
    }

    public void process(Order order){
        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }
}
```

[к оглавлению](#SOLID)

## Последствия нарушения DIP

Вместо замены реализации, придется изменять сам класс.

[к оглавлению](#SOLID)

## Расскажите что такое автоматическое тестирование

часть процесса тестирования на этапе контроля качества в процессе разработки программного обеспечения. 
Оно использует программные средства для выполнения тестов и проверки результатов выполнения, что помогает сократить время тестирования и упростить его процесс.

[к оглавлению](#SOLID)

## Как в Java осуществляется автоматическое тестирование

С помощью библиотек для автоматического тестирования (например):

+ **Selenium**	Selenium is a set of different software tools each with a different approach to supporting test automation of web applications across many platforms.
+ **Junit**	JUnit is a simple framework to write repeatable tests. It is an instance of the xUnit architecture for unit testing frameworks.

[к оглавлению](#SOLID)

## Что такое JUnit Как использовать для тестирования

JUnit – это Java фреймворк для тестирования, т. е. тестирования отдельных участков кода, например, методов или классов.
Тест это отдельный класс.

```java
import org.junit.Test;
import junit.framework.Assert;
 
public class MathTest {
    @Test
    public void testEquals() {
        Assert.assertEquals(4, 2 + 2);
        Assert.assertTrue(4 == 2 + 2);
    }
 
    @Test
    public void testNotEquals() {
        Assert.assertFalse(5 == 2 + 2);
    }
}
```

[Подробней обзор JUnit](http://java-online.ru/blog-junit.xhtml)

[к оглавлению](#SOLID)

## Что такое функциональное тестирование чем отличается от модульного

Обычно используют два вида автоматических тестов:
+ **Модульное тестирование** (тестирование отдельных частей продукта, обычно отдельных функций/методов)
+ **Функциональное тестирование** — тестирование некого функционала продукта, при этом продукт воспринимается как единый «чёрный ящик».

Самое главное — даже успешное прохождение всех юнит-тестов не гарантирует правильной работы продукта: 
ведь одна и та же функция может быть использована в различных частях системы, 
в то время как юнит-тест писался для неё с оглядкой лишь на один вариант использования. 

Функциональные тесты полностью определяют (по крайней мере должны) работоспособность продукта. 
И прежде всего нужны заказчику/руководителю разработки. 
Юнит тестирование прежде всего нужно самим разработчикам, 
для быстрого нахождения ошибок или проверки последствий рефакторинга.

[к оглавлению](#SOLID)

## Расскажите про принцип TDD

Разработка через тестирование (англ. test-driven development, TDD) — техника разработки программного обеспечения, 
которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, 
покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, 
и под конец проводится рефакторинг нового кода к соответствующим стандартам.

[к оглавлению](#SOLID)

## Расскажите про принцип BDD

BDD (сокр. от англ. Behavior-driven development, дословно «разработка через поведение») — это методология разработки программного обеспечения, 
являющаяся ответвлением от методологии разработки через тестирование (TDD).

Основной идеей данной методологии является совмещение в процессе разработки чисто технических интересов и интересов бизнеса, 
позволяя тем самым управляющему персоналу и программистам говорить на одном языке. 
Для общения между этими группами персонала используется предметно-ориентированный язык, основу которого представляют конструкции из естественного языка, 
понятные неспециалисту, обычно выражающие поведение программного продукта и ожидаемые результаты.

BDD фокусируется на следующих вопросах:

+ С чего начинается процесс.
+ Что нужно тестировать, а что нет.
+ Сколько проверок должно быть совершено за один раз.
+ Что можно назвать проверкой.
+ Как понять, почему тест не прошёл.

Исходя из этих вопросов, BDD требует, чтобы имена тестов были целыми предложениями, которые начинаются с глагола в сослагательном наклонении и следовали бизнес целям. Описание приемочных тестов должно вестись на гибком языке пользовательской истории, например,

```java
Как [роль того, чьи бизнес интересы удовлетворяются] я хочу, чтобы [описание функциональности так, как она должна работать], для того чтобы [описание выгоды].
```

Критерии приёмки должны быть описаны через сценарий, который реализует пользователь, чтобы достигнуть результата.

[к оглавлению](#SOLID)

## Что такое тестирование черным ящиком

тестирование черного ящика – это:
+ тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего устройства компонента или системы.
+ тест-дизайн, основанный на технике черного ящика – процедура написания или выбора тест-кейсов на основе анализа 
функциональной или нефункциональной спецификации компонента или системы  без знания ее внутреннего устройства.

Почему именно «черный ящик»? Тестируемая программа для тестировщика – как черный непрозрачный ящик, содержания которого он не видит. 
Целью этой техники является поиск ошибок в таких категориях:

+ неправильно реализованные или недостающие функции;
+ ошибки интерфейса;
+ ошибки в структурах данных или организации доступа к внешним базам данных;
+ ошибки поведения или недостаточная производительности системы;

Таким образом, мы не имеем представления о структуре и внутреннем устройстве системы. 
Нужно концентрироваться на том, что программа делает, а не на том, как она это делает.

[к оглавлению](#SOLID)