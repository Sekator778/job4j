## GC

+ [1. Чем java отличается от с++?](#1-Чем-java-отличается-от-с)
+ [2. Что такое менеджер памяти?](#2-Что-такое-менеджер-памяти)
+ [3. Какой механизм используется в Java для управления памятью?](#3-Какой-механизм-используется-в-Java-для-управления-памятью)
+ [4. Опишите процесс работы сборщика мусора?](#4-Опишите-процесс-работы-сборщика-мусора?)
+ [5. Какие алгоритмы сборщика вы знаете?](#5-Какие-алгоритмы-сборщика-вы-знаете?)
+ [6. Чем отличаются сборщики мусора?](#6-Чем-отличаются-сборщики-мусора?)
+ [7. Расскажите про утилиты для анализа памяти?](#7-Расскажите-про-утилиты-для-анализа-памяти?)
+ [8. Что такое ссылки?](#8-Что-такое-ссылки?)
+ [9. Какие типы ссылок вы знаете?](#9-Какие-типы-ссылок-вы-знаете?)
+ [10. Чем они отличаются?](#9-Какие-типы-ссылок-вы-знаете?)
+ [11. Расскажите про String pool, Int pool.](#11-Расскажите-про-String-pool,-Int-pool.)
+ [12. Расскажите о String intern](#12-Расскажите-о-String-intern)
+ [13. Расскажите что такое профайлер](#13-Расскажите-что-такое-профайлер)
+ [14. Расскажите, как использовать VisualVM.](#14-Расскажите-как-использовать-VisualVM)
+ [15. Расскажите, чем отличается sampling от profiling](15-Расскажите-чем-отличается-sampling-от-profiling)
+ [16. Расскажите о benchmark. Приведите примеры кода.](16-Расскажите-о-benchmark-Приведите-примеры-кода)
+ [17. Расскажите о методы finalized.](17-Расскажите-о-методы-finalized)
+ [18. Расскажите о методы clone? Deep clone and shallow clone.](18-Расскажите-о-методы-clone-Deep-clone-and-shallow-clone)
+ [19. Расскажите о Stack Heap](19-Расскажите-о-Stack-Heap)
+ [20. Стек и куча в Java](#20-Стек-и-куча-в-Java)
+ [Дополнительно](#Дополнительно)

## 1 Чем java отличается от с

 1. В Java единственным глобальным пространством имен является классовая иерархия. 
 В этом языке просто невозможно создать глобальную переменную, не принадлежащую ни одному из классов.
 
 2. В Java оператора goto нет. В ней есть зарезервированное ключевое слово goto
 
 3. Указатели или адреса в памяти - наиболее мощная и наиболее опасная черта C++.
 
 4. в Java нет функций malloc() , free(). Распределение памяти в С, а значит и в C++, 
 опирается на инь и янь ненадежного кода - на вызовы библиотечных функций malloc() и free().
 "Утечка памяти" (memory leak) приводит к постепенному замедлению работы программы по мере того, как системе виртуальной
  памяти приходится сбрасывать на диск неиспользуемые страницы с мусором. И, наконец, когда все системные ресурсы исчерпаны,
   программа неожиданно аварийно завершается, а вы начинаете ломать голову над этой проблемой. В C++ добавлены два оператора
    - new и delete, которые используются во многом аналогично функциям malloc() и free(). Программист по-прежнему 
    отвечает за то, чтобы каждый неиспользуемый объект, созданный с помощью оператора new, был уничтожен оператором delete.
  в Java нет функций malloc() , free(). Поскольку в ней каждая сложная структура данных - это объект, память под такие
  структуры резервируется в куче (heap) с помощью оператора new. Реальные адреса памяти, выделенные этому объекту, могут
   изменяться во время работы программы, но вам не нужно об этом беспокоиться. Вам даже не придется вызывать free ()
    или delete, поскольку Java - система с так называемым сборщиком мусора. Сборщик мусора запускается каждый раз, когда 
    система простаивает, либо когда Java не может удовлетворить запрос на выделение памяти.
    
 5. Хрупкие типы данных
    C++ получил в наследство от С все обычные типы данных последнего. Эти типы служат для представления целых и 
    вещественных чисел различных размеров и точности. К несчастью, реальный диапазон и точность этих типов колеблется 
    в зависимости от конкретной реализации транслятора. Поведение кода, который прекрасно транслируется и выполняется 
    на одной машине, может радикально отличаться при смене платформы. Различные трансляторы C++ могут резервировать 
    под целый тип 16, 32 или 64 бита в зависимости от разрядности машинного слова.
        В Java эта проблема решена, поскольку, в ней для всех базовых числовых типов независимо используются определенные
         соглашения, не зависящие от конкретной реализации среды. Не исключено, что на некоторых 
     архитектурах реализовать работу с числами таких размеров в интерпретаторе Java окажется трудно, либо реализация будет 
     неэффективна, однако это единственный способ гарантировать воспроизводимые результаты на широком спектре платформ.
     
 6. Ненадежное приведение типов
    Приведение типов в С и C++ - мощный механизм, который позволяет произвольным образом изменять тип указателей. 
    Такой техникой надо пользоваться с крайней осторожностью, поскольку в С и С++ не предусмотрено средств, позволяющих 
    обнаруживать неправильное использование приведения типов. Поскольку объекты в C++ - это просто указатели на адреса памяти,
     в этом языке во время исполнения программы нет способа обнаруживать случаи приведения к несовместимым типам.
        Дескрипторы объектов в Java включают в себя полную информацию о классе, представителем которого является объект,
     так что Java может выполнять проверку совместимости типов на фазе исполнения кода, возбуждая исключение в случае ошибки.
 7. Ненадежные структуры
    С++ пытается предоставить программисту возможность инкапсуляции данных посредством объявления структур (struct)
     и полиморфизм с помощью объединений (union). Эти две конструкции прикрывают критические и катастрофические 
     машинно-зависимые ограничения по размеру и выравниванию данных.
        В Java нет конструкций struct и union, все это объединено в концепции классов.
[к оглавлению](#GC)   

## 2 Что такое менеджер памяти
Менеджер памяти — часть системы (программы или ОС), обрабатывающая запросы на выделение и освобождения оперативной памяти.

## 3 Какой механизм используется в Java для управления памятью
1) В Java используется автоматическое управление памятью, называемое "сборка мусора".
2) Все создаваемые программой объекты находятся в области памяти под названием "куча" (heap).
2*) JVM использует больше памяти, чем занимает куча. Для методов Java и стеков потоков выделяется память отдельно от кучи.
3) Когда объекты занимают в куче много места, происходит очистка ее от уже не используемых, "мертвых" объектов - сборка мусора.
4) Сборщик мусора - это отдельный поток, который действует автоматически и в общем случае не требует внимания программиста,
 позволяя тому сосредоточиться на бизнес-логике.
 
## 4 Опишите процесс работы сборщика мусора?
1) Все новые объекты, за исключением очень больших, попадают в Young Generation. Очень большие - могут сразу попасть в Old.
2) В первую очередь сборщик собирает Young Generation. Объекты, которые пережили несколько сборок, могут быть "повышены" до Old Generation.
3) Объекты в Old Generation собираются тогда, когда памяти, очищенной в Young Generation, уже недостаточно.
4) Для сборки Young и Old Generation могут применяться разные алгоритмы - более быстрый или более "вдумчивый", но освобождающий больше памяти.
5) Процесс сборки примерно таков:
!--- 5.1) Пометить все "живые" объекты.
!--- 5.2) Удалить из памяти все "мертвые" объекты.
!--- 5.3) (Желательно) Переставить оставшиеся объекты так, чтобы они компактно занимали одну область.
!--- 5.4) Получилась большая свободная область памяти для новых объектов.
[к оглавлению](#GC)   
## 5 Какие алгоритмы сборщика вы знаете?
1) Последовательный (serial) или параллельный (parallel) - использовать ли одно ядро процессора или несколько.
2) Действующий параллельно с приложением (concurrent) или "остановись, мгновенье" (stop-the-world").
3) Уплотняющий (compacting), не уплотняющий (non-compacting) или копирующий (copying).
--- 3.1) Уплотняющий сдвигает после очистки оставшиеся живые объекты, чтобы создать за ними большой блок свободной памяти
--- 3.2) Не сдвигающий - так и оставляет кусками. Это быстрее, но возникает проблема "влезет ли туда объект".
--- 3.3) Копирующий - копирует ("эвакуирует") живые объекты в другую область памяти.
[к оглавлению](#GC)   
## 6 Чем отличаются сборщики мусора?
1) Пропускная способность (throughput) - процент времени, когда работает приложение, а не сборщик мусора.
2) Накладные расходы (overhead) - процент времени, когда работает сборщик мусора.
3) Длина паузы (pause time) - время, на которое приостанавливается приложения при работе сборщика мусора.
4) Частота собирания (collection frequency) - как часто включается сборщик мусора при работе приложения.
5) Отпечаток (footprint) - какого размера получается куча (heap), учитывая работу сборщика мусора.
6) Своевременность (promptness) - время между тем, когда объект стал мусором ("умер") и тем, когда сборщик освободил занятую им память.
[к оглавлению](#GC)   
## 7 Расскажите про утилиты для анализа памяти?
1) jps - запущенные процессы на jvm и их PID
2) jmap - информация о GC, heap, generations
(с java 9: jhsdb --jmap --pid <pid>)
2) jstack - информация о процессах, их stacktrace
3) jconsole (GUI) - объединяет jmap и jstack
[к оглавлению](#GC)   
## 8 Что такое ссылки?
Ссылки в Java — указатели на объекты. Другими словами, ссылка — это переменная, содержащая адрес ячейки памяти, 
в которой хранится объект. Кроме того, ссылка может быть инициализирована как null — нулевая ссылка, не указывающая ни 
на какой объект в памяти (именно это значение является значением по умолчанию). Внутри класса в нестатическом контексте 
также может быть использована ссылка this, указывающая на текущий объект, и ссылка super, указывающая на текущий объект
 суперкласса.)
[к оглавлению](#GC)   
## 9 Какие типы ссылок вы знаете?
1) Strong (сильные)
2) Soft ("мягкие")
3) Weak ("слабые")
4) Phantom ("фантомные")

В Java различают переменные примитивного и ссылочного типа. К примитивным относят 8 типов — пять целочисленных,
 два для чисел с плавающей точкой и логический тип boolean. Все остальные типы данных относятся к ссылочным типам. 
Это значит, что объявленная переменная этого типа хранит не состояние объекта, а ссылку на него, сам же объект хранится
 в определённой области памяти (куче). Создание нового класса, абстрактного класса, интерфейса или перечисления
 равносильно определению нового ссылочного типа данных. В отличие от создания объектов, объявление ссылок типа
 абстрактный класс либо интерфейс не запрещено.
 Ссылка
 Абстрактный класс java.lang.ref.Reference предоставляет базу для ссылочных классов. В нём определены следующие методы:
 
    get — метод, возвращающий сильную ссылку на объект, на который указывает ссылка.
    clear — очищает ссылку.
    isEnqueued и enqueue, отвечающие за взаимодействие ссылки и объекта ReferenceQueue.
    
[Мягкая ссылка]
Мягкая ссылка — объект класса java.lang.ref.SoftReference. Особенность такой ссылки в том, что если она указывает на 
объект, на который не указывают сильные ссылки, этот объект может быть удалён сборщиком мусора в случае угрозы OutOfMemoryError.
Несколько примеров использования мягких ссылок:
Кэширование. В частности, этот подход использован в классе java.lang.Class — информация о полях, конструкторах и методах 
класса закэширована с помощью мягких ссылок.
Защита от OutOfMemoryError при получении потенциально огромного количества информации. В этом случае данные всё равно
не будут обработаны, но вовремя удалённый объект позволит серверу продолжить работу в штатном режиме, тогда как системная
ошибка нехватка памяти может дестабилизировать работу других Java-приложений на этом сервере.[9]
Объявление мягкой ссылки:
SoftReference<Thing> thing = new SoftReference<Thing>(new Thing()); //мягкая ссылка на объект класса Thing

[Слабая ссылка]
Слабая ссылка — объект класса java.lang.ref.WeakReference. Особенность такой ссылки в том, что если она указывает на объект,
на который не указывают сильные и мягкие ссылки, этот объект может быть удалён сборщиком мусора.

Несколько примеров использования слабых ссылок:

Ассоциация объектов. Например, имеется множество объектов Action, каждый из которых создаётся, запускаем на выполнение
некоторую логику и после того, как она отработает, более не нужен. Пусть для каждого такого объекта создаётся уникальная 
строка-идентификатор. Сопоставить идентификатор и Action можно с помощью ассоциативного массива (Map). В этом случае в 
массиве будет храниться сильная ссылка на каждый Action, а значит, они не будут удаляться из памяти. Чтобы избежать этого,
можно хранить в Map слабые ссылки на Action. Как только Action завершит работу и на него пропадут сильные ссылки, он будет удалён;
до тех же пор к нему можно будет обращаться по сопоставленному идентификатору.
WeakHashMap — представитель Java Collections Framework, в основе которого лежат слабые ссылки. В отличие от описанного выше
подхода, хранит слабые ссылки на ключи. Когда на ключ не остаётся сильных ссылок, он удаляется сборщиком мусора, затем с
помощью ReferenceQueue определяется, какой ключ был удалён. Соответствующее ему значение также удаляется.
С помощью слабых ссылок можно обеспечить отсутствие дублирующихся объектов: в классе создаётся пул слабых ссылок на объекты
и реализуется метод intern() (по аналогии с одноименным методом в классе java.lang.String). Вызванный на объекте, этот 
метод либо вернёт ссылку на объект из пула, если в нём хранится объект, равный данному, либо поместит этот объект в пул.

[Фантомная ссылка]
Фантомная ссылка — объект класса java.lang.ref.PhantomReference. Объект, на который существуют только фантомные ссылки,
доступен сборщику мусора. В отличие от описанных выше типов ссылок, фантомная ссылка не даёт пользователю возможности 
«спасти» объект, создав на него сильную ссылку: метод get на ней всегда возвращает null.

Зато с помощью фантомной ссылки можно определить, что объект собирается быть удалён. В силу этих особенностей фантомная
ссылка бесполезна без объекта ReferenceQueue, поэтому для неё определён единственный конструктор:

ReferenceQueue<Wiki> queue = new ReferenceQueue<Wiki>(); //создание очереди 
PhantomReference<Wiki> ref = new PhantomReference<Wiki>(new Wiki("cyclowiki.org"), queue);

Основное предназначение фантомных ссылок — замена методу finalize, имеющему большое количество недостатков.
С их помощью можно реализовать логику подготовки объекта к удалению, например освобождение захваченных им ресурсов,
очистка сессии, сохранение состояния или логгирование. Фантомная ссылка, указывающая на удаляемый объект, попадает
в ReferenceQueue, откуда она может быть извлечена. Поскольку базовая фантомная ссылка не предоставляет пользователю 
возможности определить, на какой именно объект она ссылается, стоит реализовывать собственного потомка класса PhantomReference,
хранящего идентификатор объекта (не ссылку на сам объект, ибо это будет сильная ссылка — объект перестанет быть доступен
сборщику мусора). В таком случае после обращения к идентификатору можно однозначно определить, какой объект был удалён,
и выполнить все необходимые операции.
[к оглавлению](#GC)   
## 11 Расскажите про String pool, Int pool.
Объект String является наиболее используемым классом в языке Java.
Благодаря неизменности Strings в Java, JVM может оптимизировать объем памяти, выделенный для них, сохраняя только одну 
копию каждого литерала String в пуле . Этот процесс называется interning 
String Pool - это область хранения в куче Java.

Распределение строк, как и все объекты , оказывается дорогостоящим делом как в отношении времени, так и памяти.
 JVM выполняет некоторые шаги при инициализации строковых литералов, чтобы повысить производительность и уменьшить 
 накладные расходы памяти. Чтобы уменьшить количество объектов String, созданных в JVM, класс String хранит пул строк.
 
Когда мы создаем переменную String и присваиваем ей значение, JVM ищет в пуле String с равным значением.
Если найден, компилятор Java просто возвратит ссылку на свой адрес памяти, без выделения дополнительной памяти.
Если он не найден, он будет добавлен в пул (интернирован) и его ссылка будет возвращена.

Теперь я покажу вам реализацию и работу пула строк на примере.
Но перед этим короткое напоминание!
Как вы знаете, если вы сравниваете 2 объекта с помощью оператора ==, он сравнивает адреса в памяти.
public class StringPoolExperiment {
  
    public static void main(String[] args) {
        String s1 = "Rachel";
        String s2 = "Rachel";
        String s3 = new String("Rachel");
        String s4 = new String("Rachel").intern();
  
        System.out.println(s1 == s2); // true
        System.out.println(s1 == s3); // false
        System.out.println(s1 == s4); // true
    }
}
# Примечание о Java 9
До Java 8 строки представлялись в виде массива символов - char [] , закодированного в UTF-16 ,
так что каждый символ использует два байта памяти.
В Java 9 представлено новое представление, называемое Compact Strings. Этот новый формат будет выбирать подходящую 
кодировку между char [] и byte [] в зависимости от сохраняемого содержимого.
Поскольку новое представление String будет использовать кодировку UTF-16 только при необходимости, объем памяти кучи 
будет значительно ниже, что, в свою очередь, приводит к меньшим издержкам сборщика мусора в JVM.

[# Расскажите про Integer pool в Java.]
1) В Java существует пул объектов-оберток примитивов. Он создается статически, при инициализации соответствующего класса.
2) По спецификации пул используется для переменных: 1) byte и boolean; 2) int и long в интервале [-128...127] и 3) 
char в интервале [0...127].
3) Для таких объектов при автобоксинге (а также при вызове метода valueOf()) не будет создаваться новый объект, 
а будет возвращаться объект из пула.
4) Например, Integer.valueOf(127) == Integer.valueOf(127), а вот Integer.valueOf(128) != Integer.valueOf(128).
5) Ссылка на кэш (массив со ссылками на объекты пула) - статическая переменная внутреннего статического класса 
(например, Integer.IntegerCache) или статический член класса (Boolean.TRUE).
[к оглавлению](#GC)   
## 12 Расскажите о String intern
Метод intern () создает точную копию объекта String в памяти кучи и сохраняет ее в пуле констант String .
Обратите внимание, что если в пуле констант String существует другая строка с таким же содержимым , то новый объект
не будет создан, а новая ссылка будет указывать на другую строку.
 
 @Test
 public void whenIntern_thenCorrect() {
     String s1 = "abc";
     String s2 = new String("abc");
     String s3 = new String("foo");
     String s4 = s1.intern();
     String s5 = s2.intern();
     assertFalse(s3 == s4);
     assertTrue(s1 == s5);
 }
[к оглавлению](#GC)   
## 13 Расскажите что такое профайлер
Java Profiler - это инструмент, который отслеживает конструкции и операции Java-байт-кода на уровне JVM . 
Эти конструкции и операции кода включают создание объектов, итеративные выполнения (включая рекурсивные вызовы), 
выполнение методов, выполнение потоков и сборку мусора.
Иногда написание кода, который просто запускается, недостаточно. Возможно, мы захотим узнать, что происходит внутри, 
например, как распределяется память, последствия использования одного подхода к кодированию по сравнению с другими, 
последствия параллельных выполнений, области повышения производительности и т. Д. Для этого мы можем использовать 
профилировщики.
JProfiler - лучший выбор для многих разработчиков. Благодаря интуитивно понятному пользовательскому интерфейсу JProfiler предоставляет интерфейсы для просмотра производительности системы, использования памяти, потенциальных утечек памяти и профилирования потоков.
С помощью этой информации мы можем легко узнать, что нам нужно оптимизировать, устранить или изменить - в базовой системе.
[к оглавлению](#GC)   
## 14 Расскажите, как использовать VisualVM.
Java VisualVM - это упрощенный, но надежный инструмент профилирования для приложений Java. По умолчанию этот инструмент
входит в комплект Java Development Kit (JDK). Его работа зависит от других автономных инструментов, предоставляемых 
в JDK, таких как JConsole , jstat , jstack , jinfo и jmap .
Одним интересным преимуществом Java VisualVM является то, что мы можем расширить его для разработки новых функций в виде плагинов . Затем мы можем добавить эти плагины во встроенный центр обновлений Java VisualVM.
[к оглавлению](#GC)   
## 15 Расскажите, чем отличается sampling от profiling? Это типы аудита. Режим работы в профайлере.
Java VisualVM поддерживает локальное и удаленное профилирование , а также профилирование памяти и процессора. 
Подключение к удаленным приложениям требует предоставления учетных данных (имя хоста / IP и пароль при необходимости), 
но не обеспечивает поддержку туннелирования ssh . Мы также можем включить профилирование в режиме реального времени с 
мгновенными обновлениями (обычно каждые 2 секунды)## 16 Расскажите о benchmark. Приведите примеры кода.
[к оглавлению](#GC)   
## 17 Расскажите о методы finalized.
1) Метод finalize() вызывается тогда, когда сборщик мусора уже пометил его доступным для удаления ("мертвый"), но до непосредственного удаления объекта из памяти.
2) Метод предназначен для автоматического освобождения системных ресурсов, связанных с объектом.
3) В случае, если метод finalize() у класса переопределен (от Object.finalize), объект этого класса попадает в отдельную очередь (отдельный поток) на финализацию.
4) Если не переопределен (стандартный Object.finalize) - то не попадает, а сразу очищается.
Может ли быть так, что метод Object.finalize() на объекте будет не вызван совсем?
1) Если объект помечен сборщиком мусора как "доступный для сборки", и в это время JVM завершает свою работу.
2) Если объект оставался "живым" до завершения работы JVM.
[к оглавлению](#GC)   
#Как в приложении явно запустить finalize() для всех ждущих финализации объектов?
System.runFinalization()
[к оглавлению](#GC)   
#Что делает метод System.runFinalization()?
Метод явно запускает finalize() для всех объектов, помеченных для удаления и ждущих в очереди на выполнение finalize().
После этого объект будет очищен из памяти сборщиком мусора.
[к оглавлению](#GC)   
#Как обрабатываются исключения, выброшенные во время работы метода finalize()?
Никак - поток-финализатор просто их пропускает.

## 18 Расскажите о методы clone? Deep clone and shallow clone
Клон является точной копией оригинала. В Java это по сути означает возможность создания объекта с таким же состоянием, 
что и исходный объект. Метод Java clone()предоставляет эту функциональность.
example ---
class User implements Cloneable
  public User clone() throws CloneNotSupportedException {
        return (User) super.clone();
 --- Здесь мы добавили метод clone типа User, который через super вызывает метод clone у класса Object.
 Java Shallow Copy
Мелкий клон - это «реализация по умолчанию» в Java. В переопределенном cloneметоде, если вы не клонируете все типы 
объектов (не примитивы), то вы делаете поверхностную копию.   

Java Deep Copy
Глубокий клон - желаемое поведение в большинстве случаев. В глубокой копии мы создаем клон, который не зависит от 
исходного объекта, и внесение изменений в клонированный объект не должно влиять на исходный объект.   

Столь глубокое клонирование требует удовлетворения следующих правил: 
Не нужно отдельно копировать примитивы.1) Stack (стек) - область памяти для хранения ЛОКАЛЬНЫХ переменных, создаваемых 
в методе.
Все классы-члены в исходном классе должны поддерживать клонирование, а в методе clone исходного класса в контексте 
должны вызываться super.clone()все классы-члены.2) Если локально создается объект, то сам объект помещается в Heap, 
а ссылка на него - в Stack.
Если какой-либо класс-член не поддерживает клонирование, тогда в методе clone необходимо создать новый экземпляр этого 
класса-члена и скопировать все его атрибуты один за другим в новый объект класса-члена. Этот новый объект класса-члена 
будет установлен в клонированном объекте.3) Stack значительно меньше, чем Heap, скорость доступа - значительно быстрее.
4) Если память стека полностью занята (н-р бесконечная рекурсия), выбрасывается StackOverflowException.
5) Память Stack не требует сборщика мусора - блок полностью очищается при выходе из метода.
6.1) Устройство: по принципу LIFO. Вызван метод - ему выделяется блок стек-памяти и кладется "сверху".
6.2) Внутри вызван подметод - выделяется еще блок памяти и кладется "сверху".
6.3) Всегда доступен только последний, самый "верхний" блок памяти.
6.4) Метод отработал - его верхний блок памяти очищается, становится доступен более нижний блок - обрамляющего метода.
[к оглавлению](#GC)   

## 19 Расскажите о Stack Heap
Heap - это большой блок памяти, предназначенный для хранения объектов, создаваемых в ходе работы приложения на Java-машине
1) Heap ("куча") - область памяти, выделенная JVM для размещения объектов.
2) Абсолютно все объекты, созданные в ходе работы приложения, размещаются в heap.
3) Мертвые объекты собираются сборщиком мусора.
4) Обычно делится на Young и Old Generation.
5) Работает медленнее, чем Stack память.
6) Если нет места под объект после сборки мусора, выкидывается OutOfMemoryException.
[к оглавлению](#GC)   

## 20 Стек и куча в Java

Для оптимальной работы приложения JVM делит память на область стека (stack) и область кучи (heap). Всякий раз,
когда мы объявляем новые переменные, создаем объекты или вызываем новый метод, JVM выделяет память для этих операций в стеке или в куче
тек работает по схеме LIFO (последним вошел, первым вышел). Всякий раз, когда вызывается новый метод, содержащий
 примитивные значения или ссылки на объекты, то на вершине стека под них выделяется блок памяти

Когда метод завершает выполнение, блок памяти, отведенный для его нужд, очищается, и пространство становится доступным для следующего метода
Основные особенности стека
Помимо того, что мы рассмотрели, существуют и другие особенности стека:
Он заполняется и освобождается по мере вызова и завершения новых методов
Переменные в стеке существуют до тех пор, пока выполняется метод в котором они были созданы
Если память стека будет заполнена, Java бросит исключение java.lang.StackOverFlowError
Доступ к этой области памяти осуществляется быстрее, чем к куче
является потокобезопасным, поскольку для каждого потока создается свой отдельный стек

2. Куча

Эта область памяти используется для объектов и классов. Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке

Эти объекты имеют глобальный доступ и могут быть получены из любого места программы
Эта область памяти разбита на несколько более мелких частей, называемых поколениями:
Young Generation — область где размещаются недавно созданные объекты. Когда она заполняется, происходит быстрая сборка мусора
Old (Tenured) Generation — здесь хранятся долгоживущие объекты. Когда объекты из Young Generation достигают
 определенного порога "возраста", они перемещаются в Old Generation
Permanent Generation — эта область содержит метаинформацию о классах и методах приложения, но начиная с Java 8
 данная область памяти была упразднена.
 
В Java -Xms установить начальный размер кучи Java,
     -Xmx установить максимальный размер кучи Java.
     пример
     # Start with 128MB of memory, and allow the Java process to use up to 1024MB of memory.
-->     java -Xms128m -Xmx1024m

Если процесс Java превысил -Xmx максимальный размер кучи Java,  java.lang.OutOfMemoryError будет брошен.

[к оглавлению](#GC)

## Дополнительно

https://quizlet.com/373814147/%D0%9F%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-gc-%D0%BF%D1%80%D0%BE%D1%84%D0%B8%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-flash-cards/     

java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal -version

Если параметр объявлен с "=" , то это значение по умолчанию.
Если с ":=" , то параметр был переопределен.

Полное описание всех параметров на сайте oracle.

Значения, выставляемые по умолчанию:
* Для серверного ПК:
- Parallel (Throutput) collector
- Xms (начальный размер Heap) = 1/64 доступной памяти
- Xmx (максимальный размер Heap) = 1/4 памяти
* Для прочих устройств:
- Serial gc
- Xm* параметры такиеже

Вариант оптимизации: устанавливать Xms = Xmx, чтобы ускорить работу программы, за счет уменьшения числа изменений объема памяти

Виды сборщиков мусора

Serial
-XX:+UseSerialGC
Используется в клиентских java машинах.
Обе области: yang и old работают в 1 поток
Вариант оптимизации - это множество независимых программ работающих параллельно на 1 машине.
В этом случае однопоточный gc создан меньше нагрузки, чем множество многопоточных

Parallel
-XX:+UseParallelGC
Yang GC работает в параллельном режиме
Olg GC по прежнему однопоточный
Число потоков задается параметром "-XX:ParallelGCThreads" - по умолчанию = числу ядер процессора. Если на машине запущенно множество программ, то число параллельных потоков можно снизить.
Подходит для серверных приложений, где важен объем обрабатываемых данных, а не скорость отклика, т.к. очистка происходит с остановкой основной программы.

G1
-XX:+UseG1GC
Этот коллектор используется по умолчанию в серверных приложениях.

По принципу работы G1 схож с CMS, но имеет ряд преимуществ:
* Выполняется конкурентно как CMS gc
* Память дефрагментируется без остановки основного цикла программы
* Фиксированный (предсказуемый) размер паузы gc
* Пропускная способность остается достаточно высокой
* Не требует дополнительных 20% озу, как CMS gc (но все равно нужны 10% = G1ReservePercent)

Достигается это за счет того, что вся память делится на 2048 регионов (-XX:G1HeapRegionSize) от 1 до 32 МБ (в зависимости от размера кучи).
Выжившие объекты копируются из своего региона в свободный (дефрагментация), этот процесс дискретный и может быть остановлен в любой момент (фиксированная пауза)
Желательно чтобы размер объекта был от 50-100% размера региона. Если объект больше региона, то он будет хранится в смежных регионах, что может вызывать задержки при обработке.

Параметры коллектора, на которые стоит обратить внимание:

-XX:MaxGCPauseMillis=200
Ставьте этот параметр = 90% от необходимого времени отклика

-XX:ConcGCThreads
кол-во процессов параллельной обработки регионов

-XX:InitiatingHeapOccupancyPercent=45
заполненность heap, после которой начинается gc

-XX:G1ReservePercent=10
резерв памяти, для защиты от переполнения

GC Root: локальные переменные и параметры методов, java-потоки, статичные переменные, ссылки из JNI.

