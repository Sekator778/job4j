
## FP Labmda Stream API

+ [1. Что такое lamdba выражение](#Что-такое-lamdba-выражение)
+ [2. Что такое функциональные интерфейсы](#Что-такое-функциональные-интерфейсы)
+ [3. Перечислите функциональные интерфейсы из пакета java.util.function](#перечислите-функциональные-интерфейсы-из-пакета-javautilfunction)
+ [4. Что такое функции высшего порядка](#Что-такое-функции-высшего-порядка)
+ [5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка](#Какие-функциональные-интерфейсы-из-пакета-javautilfunction-поддерживают-функции-высшего-порядка)
+ [6. Что такое ссылки на методы](#Что-такое-ссылки-на-методы)
+ [7. Что такое ссылки на конструкторы](#Что-такое-ссылки-на-конструкторы)
+ [8. Расскажите о зоне видимости переменных в lamdba - выражениях](#Расскажите-о-зоне-видимости-переменных-в-lamdba---выражениях)
+ [9. Как быть в ситуации, если внутри lamdba - выражении операторы могут выкинуть исключение](#Как-быть-в-ситуации-если-внутри-lamdba---выражении-операторы-могут-выкинуть-исключение)
+ [10. Что такое Stream API](#Что-такое-Stream-API)
+ [11. Расскажите, как шаблон проектирования используется внутри Stream API](#Расскажите-как-шаблон-проектирования-используется-внутри-Stream-API)
+ [12. Что делает метод filter](#Что-делает-метод-filter)
+ [13. Что делает метод map](#Что-делает-метод-map)
+ [14. Что делает метод flatMap](#Что-делает-метод-flatMap)
+ [15. Что делает метод collect](#Что-делает-метод-collect)
+ [16. Что делает метод reduce](#Что-делает-метод-reduce)
+ [17. Что делает метод findFirst](#Что-делает-метод-findFirst)
+ [18. Возможно ли прервать выполнение потока по аналогии с break](#Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)
+ [19. Возможно ли пропустить элемент потока по аналогии с continue](#Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)
+ [20. Что такое Optional](#Что-такое-Optional)
+ [21. Перечислите методы Optional](#Перечислите-методы-Optional)
+ [22. Расскажите про фабричные методы List.of, Set.of, Map.of](#Расскажите-про-фабричные-методы-Listof-Setof-Mapof)
+ [23. Для чего используется ключевое слово var](#Для-чего-используется-ключевое-слово-var)
+ [24. В какие случаях можно использовать var](#В-какие-случаях-можно-использовать-var)
+ [Шпаргалка Java программиста 4. Java Stream API](https://habr.com/ru/company/luxoft/blog/270383/)

## Что такое lamdba выражение
Лямбда-выражение представляет собой блок кода, 	который можно передать в другое место, поэтому он может быть выполнен позже,
один или несколько раз
	
[к оглавлению](#FP-Labmda-Stream-API)

## Что такое функциональные интерфейсы
Это интерфейс, который содержит только 1 абстрактный метод. Основное назначение – использование в лямбда выражениях и method reference.
Такой интерфейс описываем классическую математическую функцию.
Таким образом функциональный интерфейс может содержать так же default и static методы.
К функциональному интерфейсу можно добавить аннотацию 
```java 
@FunctionalInterface 
```

[к оглавлению](#FP-Labmda-Stream-API)

## Перечислите функциональные интерфейсы из пакета java.util.function

[Подробней](https://metanit.com/java/tutorial/9.3.php)
 
Consumer<T>, Function<T,R>, Predicate<T>, Supplier<T>, UnaryOperator<T> BinaryOperator<T> и их Bi – формы

+ **Predicate<T>** - проверяет соблюдение некоторого условия.
Если оно соблюдается, то возвращается значение true. В качестве параметра лямбда-выражение принимает объект типа T
+ **BinaryOperator<T>** - принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию
и возвращает ее результат также в виде объекта типа T
+ **UnaryOperator<T>** - принимает в качестве параметра объект типа T,
выполняет над ними операции и возвращает результат операций в виде объекта типа T
+ **Function<T,R>** - представляет функцию перехода от объекта типа T к объекту типа R
+ **Consumer<T>** - выполняет некоторое действие над объектом типа T, при этом ничего не возвращая
+ **Supplier<T>** - принимает никаких аргументов, но должен возвращать объект типа T
    
[к оглавлению](#FP-Labmda-Stream-API)

## Что такое функции высшего порядка
Функции высшего порядка принимают другие функции в качестве своих параметров или возвращают другие функции в качестве своих результатов.
У языка Java — возможно, последнего среди популярных языков — наконец-то появились функции высшего порядка в форме т. н. лямбда-выражений.

[к оглавлению](#FP-Labmda-Stream-API)

## Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка
Также метод в Java может возвращать лямбда-выражение.

[к оглавлению](#FP-Labmda-Stream-API)

## Что такое ссылки на методы
Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод.
В принципе данный способ аналогичен передаче в метод лямбда-выражения.
Ссылка на метод передается в виде имя_класса::имя_статического_метода (если метод статический)
или объект_класса::имя_метода (если метод нестатический).

[к оглавлению](#FP-Labmda-Stream-API)

## Что такое ссылки на конструкторы
Можно в качестве параметров использовать конструкторы: название_класса::new
При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список параметров,
что и конструкторы класса, и должны возвращать объект данного класса.

[к оглавлению](#FP-Labmda-Stream-API)

## Расскажите о зоне видимости переменных в lamdba - выражениях
Лямбда-выражения имеют доступ к переменным области видимости, в которой их определили.
Но доступ возможен только при условии, что переменные являются effective final,
то есть либо явно имеют модификатор final, либо не меняют своего значения после инициализации

[к оглавлению](#FP-Labmda-Stream-API)

## Как быть в ситуации, если внутри lamdba - выражении операторы могут выкинуть исключение
Лямбда-выражение может генерировать исключение. Но если оно генерирует проверяемое исключение,
то последнее должно быть совместимо с исключениями, перечисленными в выражении throws
из объявления абстрактного метода в функциональном интерфейсе, либо можно поймать исключение в теле лямбда-выражения.
Как известно из функциональных интерфейсов в Stream API нельзя выбрасывать контролируемые исключения.
Если по каким-то причинам это необходимо (например, работа с файлами, базами данных или по сети),
приходится оборачивать их в RuntimeException.
[Подробней](https://www.codeflow.site/ru/article/java-lambda-exceptions)

[к оглавлению](#FP-Labmda-Stream-API)

## Что такое Stream API
Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности,
упростить операции фильтрации, сортировки и другие манипуляции с данными. Вся основная функциональность данного API
сосредоточена в пакете java.util.stream. Ключевым понятием в Stream API является поток данных.
Поток представляет канал передачи данных из источника данных.
Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.
Одной из отличительных черт Stream API является применение лямбда-выражений.
При работе со Stream API важно понимать, что все операции с потоками бывают либо терминальными (terminal),
либо промежуточными (intermediate). Промежуточные операции возвращают трансформированный поток.
Например, выше в примере метод filter принимал поток чисел и возвращал уже преобразованный поток,
в котором только числа больше 0. К возвращенному потоку также можно применить ряд промежуточных операций.
Конечные или терминальные операции возвращают конкретный результат.

[к оглавлению](#FP-Labmda-Stream-API)

## Расскажите, как шаблон проектирования используется внутри Stream API
Используется паттерн стратегия - алгоритм выбирается во время выполнения.
[Подробней](#https://www.baeldung.com/java-strategy-pattern)

[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод filter
Представляет промежуточную операцию. Он принимает в качестве параметра некоторое условие в виде объекта Predicate<T>
и возвращает новый поток из элементов, которые удовлетворяют этому условию

[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод map
Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой,
то есть получить из элемента одного типа элемент другого типа.
Для отображения используется метод map, который имеет следующее определение:
```java <R> Stream<R> map(Function<? super T, ? extends R> mapper) ```
Передаваемая в метод map функция задает преобразование от объектов типа T к типу R.
И в результате возвращается новый поток с преобразованными объектами.

[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод flatMap
Плоское отображение выполняется тогда, когда из одного элемента нужно получить несколько.
Данную операцию выполняет метод flatMap:
```java <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper) ```
Например, в примере выше мы выводим название телефона и его цену.
Но что, если мы хотим установить для каждого телефона цену со скидкой и цену без скидки.
То есть из одного объекта Phone нам надо получить два объекта с информацией, например, в виде строки.
Для этого применим flatMap:
```java
    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), new Phone("Lumia 950", 45000),
                    new Phone("Samsung Galaxy S 6", 40000));

    phoneStream
        .flatMap(p->Stream.of(
                String.format("название: %s  цена без скидки: %d", p.getName(), p.getPrice()),
                String.format("название: %s  цена со скидкой: %d", p.getName(), p.getPrice() - (int)(p.getPrice()*0.1))
        ))
        .forEach(s->System.out.println(s));
```
[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод collect
Преобразует поток в коллекцию. Мы можем написать свою реализацию функции, однако Java уже предоставляет
ряд встроенных функций, определенных в классе Collectors:
+ toList(): преобразование к типу List
+ toSet(): преобразование к типу Set
+ toMap(): преобразование к типу Map

[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод reduce
Позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат
Метод reduce выполняет терминальные операции сведения, возвращая некоторое значение - результат операции.
Он имеет следующие формы:
+ Optional<T> reduce(BinaryOperator<T> accumulator)
+ T reduce(T identity, BinaryOperator<T> accumulator)
+ U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)

Первая форма возвращает результат в виде объекта Optional<T>. Например, вычислим произведение набора чисел:
```java
Stream<Integer> numbersStream = Stream.of(1,2,3,4,5,6);
Optional<Integer> result = numbersStream.reduce((x,y)->x*y);
System.out.println(result.get()); // 720
```

Объект BinaryOperator<T> представляет функцию, которая принимает два элемента и выполняет над ними некоторую операцию,
возвращая результат. При этом метод reduce сохраняет результат и затем опять же применяет к этому результату
и следующему элементу в наборе бинарную операцию.

Если нам надо, чтобы первым элементом в наборе было какое-то определенное значение, то мы можем использовать вторую
версию метода reduce(), которая в качестве первого параметра принимает T identity.
Этот параметр хранит значение, с которого будет начинаться цепочка бинарных операций. Например:

```java
Stream<String> wordsStream = Stream.of("мама", "мыла", "раму");
String sentence = wordsStream.reduce("Результат:", (x,y)->x + " " + y);
System.out.println(sentence); // Результат: мама мыла раму
```

Допустим мы хотим найти сумму цен тех телефонов, у которых цена меньше определенного значения.
Для этого используем третью версию метода reduce:

```java
    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000),
                new Phone("Lumia 950", 45000),
                new Phone("Samsung Galaxy S 6", 40000),
                new Phone("LG G 4", 32000));

    int sum = phoneStream.reduce(0,
                (x,y)-> {
                        if(y.getPrice()<50000)
                            return x + y.getPrice();
                        else
                            return x + 0;
                },
                (x, y)->x+y);

    System.out.println(sum); // 117000
```

[к оглавлению](#FP-Labmda-Stream-API)

## Что делает метод findFirst
Возвращает первый элемент из стрима (возвращает Optional)

[к оглавлению](#FP-Labmda-Stream-API)

## Возможно ли прервать выполнение потока по аналогии с break
Stream может выполнятся в несколько параллельных потоков, поэтому прерывание может привести к некорректным результатам.
В Java 9 можно использовать ```java takeWhile ```.
Лучше использовать итератор:
```java
    Iterator<BuyOrderType> iter = market.buyOrders() // replace BuyOrderType with correct type here
                .stream()
                .filter(buyOrder -> buyOrder.price >= sellOrder.price)
                .sorted(BY_ASCENDING_PRICE).iterator();
    while (iter.hasNext()) {
        BuyOrderType buyOrder = iter.next()  // replace BuyOrderType with correct type here
        double tradeVolume = Math.min(buyOrder.quantity, sellOrder.quantity);
        double price = buyOrder.price;

        buyOrder.quantity -= tradeVolume;
        sellOrder.quantity -= tradeVolume;

        Trade trade = new Trade.Builder(market, price, tradeVolume, Trade.Type.SELL).build();
        CommonUtil.convertToJSON(trade);

        if (sellOrder.quantity == 0) {
            System.out.println("order fulfilled");
            break;
        }
    }
```

[к оглавлению](#FP-Labmda-Stream-API)

## Возможно ли пропустить элемент потока по аналогии с continue
Вместо этого можно использовать return или filter
```java
    public static void main(String[] args) {
        ArrayList<String> stringList = new ArrayList<>();
        stringList.add("a");
        stringList.add("b");
        stringList.add("c");

        stringList.stream().forEach(str -> {
            if (str.equals("b")) return; // only skips this iteration.

            System.out.println(str); // a c
        });
    }
```
[к оглавлению](#FP-Labmda-Stream-API)

## Что такое Optional
В релизе Java 8 появился новый класс Optional призванный помочь разработчикам в обработке NullPointerException.

```java
    //Пустой Optional объект
    Optional<Person> optionalPerson = Optional.empty();

    //Optional объект с ненулевым значением
    Optional<Person> optionalNonNull = Optional.of(somePerson);

    //Optional объект с возможностью нулевого значения
    Optional<Person> optionalNullable = Optional.ofNullable(somePerson);
```

Метод ifPresent() позволяет также устранить некоторую избыточность кода, следующего вида:
```java
     if(person != null) {
    	System.out.println(person);
     }
```

Те же действия, но с использованием Optional:
```java  person.ifPresent(System.out::println); ```

orElse(), orElseThrow():
Как было раньше:
```java Person personNew = person != null ? person : new Person(); ```

То же самое, но с использованием Optional:
```java Person personNew = person.orElse(new Person()); ```
Или, если не хотим создавать объект, можно выбросить исключение:
```java Person personNewThrow = person.orElseThrow(Exception::new); ```

[к оглавлению](#FP-Labmda-Stream-API)

## Перечислите методы Optional
+ Optional.empty() - возвращает Optional с null внутри
+ Optional.of(T value) - возвращает Optional с нe null значением внутри
+ Optional.ofNullable(T value) - возвращает Optional который может содержать null значение внутри

Дальше мы рассмотрим методы конкретного объекта optional.
+ filter(Predicate<? super T> predicate) - Этот метод дает возможность отфильтровать значение опционального типа.
Мы передаем ему в параметр Predicat (это стандартный функциональный интерфейс),
он возвращает булево значение, если значение true, то возвращается этот же опционал, если значение false,
то возвращается пустой опционал (Optional.empty())
+ flatMap(Function<? super T,Optional<U>> mapper) - Этот метод можно применить для изменения значения установленного
в опционале. Функция которая передается в метод flatMap должна возвращать опционал.
Если значение не установлено, вернется Optional.empty()
+ get() - Этот метод возвращает значение из опционала. Нужно аккуратно использовать этот метод,
так как он может бросить исключение NoSuchElementException, если значение в опционале равно null.
Чтобы безопасно использовать этот метод перед его вызовом надо вызвать метод isPresent()
+ ifPresent(Consumer<? super T> consumer) - Этот метод исполняет Consumer функциональный интерфейс
если значение в опционале присутствует
+ isPresent() - Возвращает булево значение true если в опционале значение есть и возвращает false если в опционале значение null
+ orElse(T other) - Этот метод используется для того, чтобы установить значение по-умолчанию в том случае
если значение в опционале отсутствует
+ orElseThrow(Supplier<? extends X> exceptionSupplier) - Этот метод используется для того, чтобы бросить исключение
которое передается в метод orElseThrow если значения в опционале не установлено
+ orElseGet(Supplier<? extends T> other) - Этот метод полный аналог метода orElse,
только принимает в себя функциональный интерфейс который должен вернуть значение

[к оглавлению](#FP-Labmda-Stream-API)

## Расскажите про фабричные методы List.of, Set.of, Map.of
С приходом Java 9 создавать immutable коллекции намного проще.

+ List
Создание списка выглядит так:
```java List<Integer> nums = List.of(1,2,3,4,5); ```
Метод of() в интерфейсе List  перегружен и принимает от одного до десяти элементов. Если хотим создать коллекцию с более чем десятью элементами, тогда будет использоваться перегруженный метод с varargs
```java static <E> List<E> of(E... elements) ```
Сделано это с целью оптимизации, так как  при каждом вызове метода c varargs будет создаваться новый массив

+ Set
```java Set<String> questions = Set.of("What?", "Where?", "When?"); ```
Set также имеет перегруженные методы, но в отличии от List, если передать дубликат в метод of(), то получим исключение
```java Set<String> questions = Set.of("What?", "What?"); // IllegalArgumentException: duplicate element: What? ```

+ Map
```java Map<String, String> params = Map.of("Name:", "John", "Surname:", "Snow", "Status:", "Unmarried"); ```
Последовательности идут парами key, value. Всего таких пар может быть 10, в отличии от List и Set.
Если в последовательности будут повторения ключей - получим исключение
```java Map.of("уникально", "наверняка", "уникально", "но это не точно"); // IllegalArgumentException: duplicate key: уникально ```

+ Вышеупомянутые коллекции нельзя изменить, при попытке получим UnsupportedOperationException;
+ В метод of() нельзя передать null, во всех коллекциях получим NullPointerException;
+ Метод of() не создает привычные ArrayList, HashSet или HashMap. В Java 9 были созданы специальные ImmutableCollections которые и возвращаются;
+ ImmutableCollections являются сериализуемыми, если содержимое тоже является сериализуемым;

[к оглавлению](#FP-Labmda-Stream-API)

## Для чего используется ключевое слово var
Одним из самых интересных нововведений Java 10 безусловно является вывод типа локальной переменной (JEP 286).
Это дает вам возможность сократить объявления переменных используя новое ключевое слово var
При обработке var, компилятор просматривает правую часть объявления,
так называемый инициализатор и использует его тип для переменной.

[к оглавлению](#FP-Labmda-Stream-API)
    
## В какие случаях можно использовать var    
var - может использоваться только в сочетании с данными.

[к оглавлению](#FP-Labmda-Stream-API)


