1. Что такое ООП?
    Подход (методология) к программированию ориетированный на объекты.
    Представление программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса,
        а классы образуют иерархию наследования.

2. Базовые концепции ООП?
    - Инкапсуляция - свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. Для Java корректно будет говорить, что инкапсуляция это «сокрытие реализации».;
    - наследование - войство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом.;
    - Полиморфизм - свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.;
    - Абстракция - выделение значимой информации и исключение из рассмотрения незначимой.

3. Укажите из каких элементов состоит класс.
    Класс состоит из полей (атрибуты) и методов (функции для работы с этими полями).

4. Что такое конструктор? Типы конструкторов?
	Конструктор — это специальный метод, который вызывается при создании нового объекта. 
	Конструктор инициализирует объект непосредственно во время создания.
	Имя конструктора совпадает с именем класса, включая регистр, 
	а по синтаксису конструктор похож на метод без возвращаемого значения.    
    - конструктор с параметрами;
    - конструктор по умолчанию.

5. Можно ли наследовать конструктор?
    Нет, но ему можно передать аргументы с помощью super.

6. Что такое перегрузка конструктора?
    Это создание конструкторов с другим набором аргументов.

7. Что такое статический метод?
    Это метод, который можно вызвать без создания объекта, напрямую через имя класса.

8. Что такое не статический метод?
    Это метод, для работы которого необходим объект.

9. Для чего используется ключевое слово this?
    Чтобы обращаться к полям и методам данного класса (объекта).
	this(), то конструктор текущего класса, можно использовать для перевызова конструктора с параметрами.

10. Какой класс является базовый родительным классов для всех классов?
    Object

11. Что такое наследование? Приведите примеры из реальной жизни.
    Это когда один объект перенимает все публичные поля и методы другого объекта.
    Млекопитающиеся > Киты > Голубой кит, горбатый кит.

12. Опишите процесс создания нового объекта.
    Объект создается с помощью ключевого слова new, которое вызывает конструктор класса,
        который инициилизирует все поля и методы и создаёт объект.
    При первом обращении к классу подгружаются все статические поля, методы и блоки инициализации.
    При создании объекта подгружаются все нестатические поля и методы по порядку.
    Потом подгружается конструктор этого объекта.
	Сначала вызываются все статические блоки от первого предка до последнего наследника. 
	Потом попарно вызываются динамический блок инициализации и конструктор в той же последовательности (от предка до последнего потомка). 

13. Как вызвать метод из родительского класса?
    с использованием ключевого слова super.

14. Что такое переопределение метода?
    Это возможность по своему написать метод родительского класса.

15. Можно ли переопределить статический метод?
    Нет, статический метод создается при инициализации класса один на все объекты

16. Что такое виртуальная функция и используются ли они в Java?
    Это функция, котора может быть переопределена наследником.
    В Java практически все функции виртуальные (private функции не могут быть переопределены
        в связи с правами видимости)

17. Что такое перегрузка метода?
    Это создание того же метода с другими аргументами.

18. Можно ли изменить тип возвращаемых тип данных при перегрузке метода?
    Можно, если аргументы отличаются, иначе JVM не поймет какой метод ей нужно вызвать.

19. Что такое множественное наследование? Как его можно реализовать в Java.
    Это наследование класса от нескольких суперклассов одновременно.
    В Java запрещено множественное наследование главным образом из-за ромбовидной проблемы.
    В Java множественное наследование разрешено в интерфейсах.
    ?Если есть необходимость использовать методы из разных классов, то можно воспользоваться
    ?    Композицией (в третем классе создать два необходимых обхекта, добавить методы, которые
    ?    обращаются к нужным методам этих объектов. И наследоваться от этого класса).

20. Что такое полиморфизм? Приведите примеры из реальной жизни.
    Это возможность работать с несколькими типами, как будьто это один и тот же тип, в то же время
        поведение каждого типа будет уникальным в зависитости от его реализации.
    Это один интерфейс, множество реализаций.
    Пульт управления один для разных моделей. Монетоприемник в каком-нибудь продающем автомате. Цоколь лампочки - это переменная определенного базового типа.
	Лампочка - созданный объект конкретного класса. Лампочки разные цоколь один.

21. Что такое инкапсуляция?
    Это скрытие полей объектов.
    Это ограничение доступа к определенным методами и полям.

22. Как реализована инкапсуляция в Java?
    Модификаторами доступа private скрываются поля объекта, и при необходимости разрешается к ним
        подкотрольный доступ через геттеры и сеттеры.

23. Что такое абстракция?
    Это абстрагирование от некоторых конкретных деталей объекта.

24. Как реализована абстракция в Java?
    С помощью ключевого слова abstract перед именем класса. В таком классе могут быть абстрактные
        методы, которые обязан реализовать дочерний класс. От абстрактного класса нельзя создать объект.

25. Что такое интерфейс?
    Это тип данных, который может содержать лишь константы, абстрактные методы (так же неабстрактные
        методы default и static). У них нету конструкторов.
    Инерфейс позволяет создавать общей тип данных для разных объектов (т.е. использование интерфейса
        гарантирует наличие определенного метода у объекта).

26. Что такое внутренний класс? Типы внутренних классов.
    Это класс вложенный в другой класс
    - InnerClass
        public class OuterClass {
            public class InnerClass{
            }
        }
        создание:
        OuterClass outerClass = new OuterClass();
        OuterClass.InnerClass innerClass = outerClass.new InnerClass();
    - StaticInnerClass
        public class OuterClass {
            public static class StaticInnerClass{
            }
        }
        создание:
        OuterClass.StaticInnerClass staticInnerClass = new OuterClass.StaticInnerClass();
    - LocalClass
        public class OuterClass {
            public void someMethod(){
                class LocalClass{
                }
            }
        }
    - Анонимный класс
        public class OuterClass {
            public void someMethod(){
                Callable callable = new Callable() {
                    @Override
                    public Object call() throws Exception {
                        return null;
                    }
                };
            }
        }

27. Что такое анонимный класс.
    Это класс, который сразу создаеся и реализуется (без имени класса) от суперкласса или интерфейса.

28. Для чего используется конструктор в абстрактном классе?
    Для инициализации полей класса.

29.Можно ли создать анонимный класс. если в классе нет конструктора по умолчанию?
    При создании анонимного класса в скобках можно передать аргументы для недефолтового конструктора.

30.Что такое композиция?
    еще более «жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель.

31.Что такое агрегация?
    отношение когда один объект является частью другого. Например Студент входит в Группу любителей физики.

32.Какие типы исключительных ситуаций бывают?
    Суперкласс исключений - Throwable - тут вся логика, остальные подклассы нужны чисто чтобы определить
        тип исключений
    - Exception (checked) - !обязательные для обработки! обычно связаны с бизнеслогикой (например нет
        файла, который необходимо прочитать. Не могу подключиться к базе данных)
    - RuntimeException (unchecked) - результат некорректного программирования (обращение к
        несуществующим элементам массива): NullPointerException, NumberFormatException,
        ClassCastException, IndexOutOfBoundsException
    - Error (unchecked) - ошибки ОС или JVM (закончилась память

33. Как обрабатываются исключительные ситуации?
    или с помощью метода try-catch или передает его выше, тому методу который его вызвал.

34. Назовите основные методы класса Object?
    - equals
    - hashCode
    - toString
    - getClass


Порядок вызовов конструкторов:
	Конструкторы вызываются в порядке наследования. От старших к младшим.

Переопределение методов:
	Совпадают имена методов и сигнатуры типов.
	Вариант метода для выполнения определяется в зависимости от типа объекта на который делается ссылка, а не типа ссылочной переменной.
	Для статических методов наоборот. Вызывается метод в зависимости от типа ссылки.

Перегузка методов:
	Совпадают имена сигнатуры разные

final
	используется для констант. если метод, то не может переопределятся. для классов - нельзя наследовать.

Иерархия исключений:
	Все исключения являются Throwable, далее делятся на Error (не обрабатываемые ошибки в самой среде выполнения) и Exception
	от Exception наследуются RunTimeException (непроверяемые ArithmeticExcepton - деление на ноль, NPE, ArrayOutOfBoundsException)
	Основные методы printStackTrace, getCause

Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?
	Сначала вызываются все статические блоки от первого предка до последнего наследника. 
	Потом попарно вызываются динамический блок инициализации и конструктор в той же последовательности (от предка до последнего потомка). 

Особенности абстрактных классов.
	Если есть хоть один абстрактный метод, то класс должен быть абстрактным. 
	Абстрактные классы нельзя создавать с помощью new, но можно использовать в качестве ссылки, для полиморфизма.

Как получить имя анонимного класса.
	имя анонимного класса anonym.getClass().toString().

Какие модификации уровня доступа вы знаете, расскажите про каждый из них?
	private (закрытый) — доступ к члену класса не предоставляется никому, кроме методов этого класса. Другие классы того же пакета также не могут обращаться к private-членам.
	default, package, friendly, доступ по умолчанию, когда никакой модификатор не присутствует — член класса считается открытым внутри своего собственного пакета, но не доступен для кода, расположенного вне этого пакета.Т.е. если package2.Class2 extends package1.MainClass, то в Class2 методы без идентификатора из MainClass видны не будут.
	protected (защищённый) — доступ в пределах пакета и классов наследников. Доступ в классе из другого пакета будет к методам public и protected главного класса. Т.е. если package2.Class2 extends package1.MainClass, то внутри package2.Class2 методы с идентификатором protected из MainClass будут видны.
	public (открытый) — доступ для всех из любого другого кода проекта
	Модификаторы в списке расположены по возрастающей видимости в программе.

Расскажите об особенностях класса с единственным закрытым (private) конструктором?
	Невозможно создать объект класса у которого единственный private конструктор за пределами класса. 
	Поэтому нельзя унаследоваться от такого класса. 
	При попытке унаследоваться будет выдаваться ошибка: There is no default constructor available in имяКласса. 
	А при попытке создать объект этого класса: ИмяКласса() has private access in ИмяКласса
	
Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
	При переопределении метода нельзя сузить модификатор доступа к методу (например с public в MainClass до private в Class extends MainClass). 
	Изменить тип возвращаемого значения при переопределении метода нельзя, будет ошибка attempting to use incompatible return type. 
	Но можно сузить возвращаемое значение, если они совместимы.
	
Где можно инициализировать статические/нестатические поля?
	Статические поля можно инициализировать при объявлении, в статическом или динамическом блоке инициализации. 
	Нестатические поля можно инициализировать при объявлении, в динамическом блоке инициализации или в конструкторе.
	
Зачем нужен оператор instanceof?
	Оператор instanceof возвращает true, если объект является экземпляром класса или его потомком.
	
Зачем нужны и какие бывают блоки инициализации?
	Бывают статические и нестатические блоки инициализации. Так же возможно создать такой блок в анонимном классе.
	Блоки инициализации представляют собой наборы выражений инициализации полей, заключенные в фигурные скобки и размещаемые внутри класса вне объявлений методов или конструкторов. 
	Блок инициализации выполняется так же, как если бы он был расположен в верхней части тела любого конструктора. 
	Если блоков инициализации несколько, они выполняются в порядке следования в тексте класса. 
	Блок инициализации способен генерировать исключения, если их объявления перечислены в предложениях throws всех конструкторов класса.

К каким конструкциям Java применим модификатор static?
	К методу.
	К внутреннему классу.
	К полю.
	К импортируемым классам (с 5-ой java). Например, import static org.junit.Assert.assertThat;
	
Какие особенности инициализации final static переменных?
	Переменные должны быть инициализированы во время объявления или в static блоке.
	
Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
	Интерфейс может содержать поля, но они автоматически являются статическими (static) и неизменными (final). 
	Все методы и переменные неявно объявляются как public
	
Каким образом из вложенного класса получить доступ к полю внешнего класса?
	Если вложенный класс не статический и поле не статическое, то можно просто обратиться к этому полю из внутреннего класса, 
	если только у внутреннего класса не существует поля с таким же литералом, 
	в этом случае нужно обращаться через ссылку на внешний класс так — OuterClass.this.имяПоля
	
Расскажите про каждый из методов класса Object.
	public final native Class getClass() — возвращает в рантайме класс данного объекта.
	public native int hashCode() — возвращает хеш-код
	public boolean equals(Object obj) — сравнивает объекты.
	protected native Object clone() throws CloneNotSupportedException — клонирование объекта
	public String toString() — возвращает строковое представление объекта.
	public final native void notify() — просыпается один поток, который ждет на “мониторе” данного объекта.
	public final native void notifyAll() — просыпаются все потоки, которые ждут на “мониторе” данного объекта.
	public final native void wait(long timeout) throws InterruptedException — поток переходит в режим ожидания в течение указанного времени.
	public final void wait() throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта.
	public final void wait(long timeout, int nanos) throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.
	protected void finalize() throws Throwable — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет.
	
Что такое метод equals()
	Это метод, определенный в Object, который служит для сравнения объектов. 
	При сравнении объектов при помощи == идет сравнение по ссылкам. 
	При сравнении по equals() идет сравнение по состояниям объектов (реализация метода equals для нового созданного класса ложится на плечи разработчиков). 
	С точки зрения математики equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным и рефлексивным.

	Рефлексивность: для любого ненулевого x, x.equals(x) вернет true;
	Транзитивность: для любого ненулевого x, y и z, если x.equals(y) и y.equals(z) вернет true, тогда и x.equals(z) вернет true;
	Симметричность: для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) вернет true.
	Также для любого ненулевого x, x.equals(null) должно вернуть false
	При переопределении equals() обязательно нужно переопределить метод hashCode(). Равные объекты должны возвращать одинаковые хэш коды.
	Хеш-код — это число. Если более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины. 
	В терминах Java, хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.

	Этот метод реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым. 
	Следует понимать, что множество возможных хеш-кодов ограничено примитивным типом int, а множество объектов ограничено только нашей фантазией. 
	Отсюда следует утверждение: “Множество объектов мощнее множества хеш-кодов”. Из-за этого ограничения, вполне возможна ситуация, что хеш-коды разных объектов могут совпасть.

	Здесь главное понять, что:
	Если хеш-коды разные, то и входные объекты гарантированно разные.
	Если хеш-коды равны, то входные объекты не всегда равны.

	Ситуация, когда у разных объектов одинаковые хеш-коды называется — коллизией. 
	Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.
	
Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы?
	Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. 
	Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.
	
Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode?
	Те, которые используют при определении метода equals(). Хэш код должен быть равномерно распределен на области возможных принимаемых значений.
	
Как вы думаете, будут ли какие-то проблемы, если у объекта, который используется в качестве ключа в hashMap изменится поле, которое участвует в определении hashCode?
	Будут. При обращении по ключу мы можем не найти значение.
	
Чем отличается абстрактный класс от интерфейса, в каких случаях что вы будете использовать?
	Абстрактные классы используются только тогда, когда есть «is a» тип отношений; 
	интерфейсы могут быть реализованы классами которые не связаны друг с другом.
	
Что такое volatile и transient? Для чего и в каких случаях можно было бы использовать default?
	volatile  — не используется кэш (имеется ввиду область памяти в которой JVM может сохранять локальную копию переменной, 
	чтобы уменьшить время обращения к переменной) при обращении к полю. 
	Для volatile переменной JVM гарантирует синхронизацию для операций чтения/записи, но не гарантирует для операций изменения значения переменной.	
	transient — указание того, что при сериализации/десериализации данное поле не нужно сериализовать/десериализовывать.

Расширение модификаторов при наследовании, переопределении и сокрытии методов. Если у класса-родителя есть метод, объявленный как private, может ли наследник расширить его видимость? А если protected? А сузить видимость?
	Действует общий принцип: расширять видимость можно, сужать нельзя. private методы видны только внутри класса, для потомков они не видны. Поэтому их и расширить нельзя.
	
Имеет ли смысл объявлять метод private final?
	Нет, такой метод и так не виден для наследников, а значит не может быть ими переопределен.
	
Что будет, если единственный конструктор класса объявлен как final?
	К конструктору не применимо ключевое слово final.
	
Что такое finalize? Зачем он нужен? Что Вы можете рассказать о сборщике мусора и алгоритмах его работы.
	Метод finalize() вызывается перед тем, как объект будет удален garbage collector (сборщик мусора, далее gc). 
	Существует много различных реализаций gc. Основа работы следующая: gc помечает объекты, на которые больше не ссылаются другие объекты для их удаления. 
	Затем на одном из проходов помеченные объекты удаляются.
	Вызов finalize() не гарантируется, т.к. приложение может быть завершено до того, как будет запущена ещё одна сборка мусора. 
	Да, можно отменить сборку объекта с помощью метода finalize(), присвоив его ссылку какому-то статическому методу.
	
Почему метод clone объявлен как protected? Что необходимо для реализации клонирования?
	Это указывает на то, что хоть метод и есть в классе Object и разработчик желает им воспользоваться, то его нужно переопределить. 
	Для этого нужно реализовать интерфейс Clonable, чтобы соблюсти контракт.
	
Что такое локальный класс?
	Класс объявленный внутри метода
	
С каким модификатором доступа может быть объявлен локальный класс ?
	у локального класса не ставится модификатор доступа
	
Может ли локальный класс иметь статические поля и методы?
	не может иметь статических полей, методов, классов (за исключением финальных);
	
Интерфейс может содержать только общедоступные константы (public final static long SOME_CONST = 1)

1. Что такое конструктор?
	Конструктор — это специальный метод, предназначенный для создания и инициализации экземпляра класса.

3. Выберите правильный конструктор:
	public Miniport(City city) { city.super(); }

Может ли абстрактный метод в абстрактном класе иметь модификатор static?
	Нет.

Сигнатура метода — это имя метода плюс параметры (причем порядок параметров имеет значение). 
	В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения.