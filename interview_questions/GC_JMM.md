## GC&JMM

+ [1. Стек и куча в Java](#1-Стек-и-куча-в-Java)


## 1 Стек и куча в Java

Для оптимальной работы приложения JVM делит память на область стека (stack) и область кучи (heap). Всякий раз,
когда мы объявляем новые переменные, создаем объекты или вызываем новый метод, JVM выделяет память для этих операций в стеке или в куче
тек работает по схеме LIFO (последним вошел, первым вышел). Всякий раз, когда вызывается новый метод, содержащий
 примитивные значения или ссылки на объекты, то на вершине стека под них выделяется блок памяти

Когда метод завершает выполнение, блок памяти, отведенный для его нужд, очищается, и пространство становится доступным для следующего метода
Основные особенности стека
Помимо того, что мы рассмотрели, существуют и другие особенности стека:
Он заполняется и освобождается по мере вызова и завершения новых методов
Переменные в стеке существуют до тех пор, пока выполняется метод в котором они были созданы
Если память стека будет заполнена, Java бросит исключение java.lang.StackOverFlowError
Доступ к этой области памяти осуществляется быстрее, чем к куче
является потокобезопасным, поскольку для каждого потока создается свой отдельный стек

2. Куча

Эта область памяти используется для объектов и классов. Новые объекты всегда создаются в куче, а ссылки на них хранятся в стеке

Эти объекты имеют глобальный доступ и могут быть получены из любого места программы
Эта область памяти разбита на несколько более мелких частей, называемых поколениями:
Young Generation — область где размещаются недавно созданные объекты. Когда она заполняется, происходит быстрая сборка мусора
Old (Tenured) Generation — здесь хранятся долгоживущие объекты. Когда объекты из Young Generation достигают
 определенного порога "возраста", они перемещаются в Old Generation
Permanent Generation — эта область содержит метаинформацию о классах и методах приложения, но начиная с Java 8
 данная область памяти была упразднена.
 
 
 
В Java -Xms установить начальный размер кучи Java,
     -Xmx установить максимальный размер кучи Java.
     пример
     # Start with 128MB of memory, and allow the Java process to use up to 1024MB of memory.
-->     java -Xms128m -Xmx1024m

Если процесс Java превысил -Xmx максимальный размер кучи Java,  java.lang.OutOfMemoryError будет брошен.
[к оглавлению](#GC&JMM)

java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal -version

Если параметр объявлен с "=" , то это значение по умолчанию.
Если с ":=" , то параметр был переопределен.

Полное описание всех параметров на сайте oracle.

Значения, выставляемые по умолчанию:
* Для серверного ПК:
- Parallel (Throutput) collector
- Xms (начальный размер Heap) = 1/64 доступной памяти
- Xmx (максимальный размер Heap) = 1/4 памяти
* Для прочих устройств:
- Serial gc
- Xm* параметры такиеже

Вариант оптимизации: устанавливать Xms = Xmx, чтобы ускорить работу программы, за счет уменьшения числа изменений объема памяти

Виды сборщиков мусора

Serial
-XX:+UseSerialGC
Используется в клиентских java машинах.
Обе области: yang и old работают в 1 поток
Вариант оптимизации - это множество независимых программ работающих параллельно на 1 машине.
В этом случае однопоточный gc создан меньше нагрузки, чем множество многопоточных

Parallel
-XX:+UseParallelGC
Yang GC работает в параллельном режиме
Olg GC по прежнему однопоточный
Число потоков задается параметром "-XX:ParallelGCThreads" - по умолчанию = числу ядер процессора. Если на машине запущенно множество программ, то число параллельных потоков можно снизить.
Подходит для серверных приложений, где важен объем обрабатываемых данных, а не скорость отклика, т.к. очистка происходит с остановкой основной программы.

G1
-XX:+UseG1GC
Этот коллектор используется по умолчанию в серверных приложениях.

По принципу работы G1 схож с CMS, но имеет ряд преимуществ:
* Выполняется конкурентно как CMS gc
* Память дефрагментируется без остановки основного цикла программы
* Фиксированный (предсказуемый) размер паузы gc
* Пропускная способность остается достаточно высокой
* Не требует дополнительных 20% озу, как CMS gc (но все равно нужны 10% = G1ReservePercent)

Достигается это за счет того, что вся память делится на 2048 регионов (-XX:G1HeapRegionSize) от 1 до 32 МБ (в зависимости от размера кучи).
Выжившие объекты копируются из своего региона в свободный (дефрагментация), этот процесс дискретный и может быть остановлен в любой момент (фиксированная пауза)
Желательно чтобы размер объекта был от 50-100% размера региона. Если объект больше региона, то он будет хранится в смежных регионах, что может вызывать задержки при обработке.

Параметры коллектора, на которые стоит обратить внимание:

-XX:MaxGCPauseMillis=200
Ставьте этот параметр = 90% от необходимого времени отклика

-XX:ConcGCThreads
кол-во процессов параллельной обработки регионов

-XX:InitiatingHeapOccupancyPercent=45
заполненность heap, после которой начинается gc

-XX:G1ReservePercent=10
резерв памяти, для защиты от переполнения

Типы ссылок в Java

