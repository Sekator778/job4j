## Servlet

+ [1. Что такое сервлет?](#1-Что-такое-сервлет)
+ [2. Какова структура веб-проекта?](#2-Какова-структура-веб-проекта)
+ [3. Что такое контейнер сервлетов?](#3-Что-такое-контейнер-сервлетов)
+ [4. Каковы задачи, функциональность контейнера сервлетов?](#4-Каковы-задачи-функциональность-контейнера-сервлетов)
+ [5. Что вы знаете о сервлет фильтрах?](#5-Что-вы-знаете-о-сервлет-фильтрах)
+ [6. Зачем нужны слушатели в сервлетах?](#6-Зачем-нужны-слушатели-в-сервлетах)
+ [7. Когда вы будете использовать фильтры, а когда слушатели?](#7-Когда-вы-будете-использовать-фильтры-а-когда-слушатели)
+ [8. Как обработать исключения, выброшенные другим сервлетом в приложении?](#8-Как-обработать-исключения-выброшенные-другим-сервлетом-в-приложении)
+ [9. Что такое дескриптор развертывания?](#9-Что-такое-дескриптор-развертывания)
+ [10. Как реализовать запуск сервлета с запуском приложения?](#10-Как-реализовать-запуск-сервлета-с-запуском-приложения)
+ [11. Что представляет собой объект ServletConfig?](#11-Что-представляет-собой-объект-ServletConfig)
+ [12. Что представляет собой объект ServletContext?](#12-Что-представляет-собой-объект-ServletContext)
+ [13. В чем отличия ServletContext и ServletConfig?](#13-В-чем-отличия-ServletContext-и-ServletConfig)
+ [14. Что такое Request Dispatcher?](#14-Что-такое-Request-Dispatcher)
+ [15. Как можно создать блокировку deadlock в сервлете?](#15-Как-можно-создать-блокировку-deadlock-в-сервлете)
+ [16. Как получить адрес сервлета на сервере?](#16-Как-получить-адрес-сервлета-на-сервере)
+ [17. Как получить информацию о сервере из сервлета?](#17-Как-получить-информацию-о-сервере-из-сервлета)
+ [18. Как получить ip адрес клиента на сервере?](#18-Как-получить-ip-адрес-клиента-на-сервере)
+ [19. Что вы знаете о классах обертках wrapper для сервлетов?](#19-Что-вы-знаете-о-классах-обертках-wrapper-для-сервлетов)
+ [20. Каков жизненный цикл сервлета и когда какие методы вызываются?](#20-Каков-жизненный-цикл-сервлета-и-когда-какие-методы-вызываются)
+ [21. Какие методы необходимо определить при создании сервлетов?](#21-Какие-методы-необходимо-определить-при-создании-сервлетов)
+ [22. В каком случае вы будете переопределять метод service?](#22-В-каком-случае-вы-будете-переопределять-метод-service)
+ [23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?](#23-Есть-ли-смысл-определить-конструктор-для-сервлета-как-лучше-инициализировать-данные)
+ [24. В чем отличия GenericServlet и HttpServlet?](#24-В-чем-отличия-GenericServlet-и-HttpServlet)
+ [25. Как вызвать из сервлета другой сервлет этого же и другого приложения?](#25-Как-вызвать-из-сервлета-другой-сервлет-этого-же-и-другого-приложения)
+ [26. Что вы знаете и в чем отличия методов forward и sendRedirect?](#26-Что-вы-знаете-и-в-чем-отличия-методов-forward-и-sendRedirect)
+ [27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?](#27-Стоит-ли-волноваться-о-“многопоточной-безопасности”-работая-с-сервлетами)
+ [28. В чем отличие между веб сервером и сервером приложений?](#28-В-чем-отличие-между-веб-сервером-и-сервером-приложений)
+ [29. Какой метод HTTP не является неизменяемым?](#29-Какой-метод-HTTP-не-является-неизменяемым)
+ [30. Почему HttpServlet класс объявлен как абстрактный?](#30-Почему-HttpServlet-класс-объявлен-как-абстрактный)
+ [31. В чем разница между методами GET и POST?](#31-В-чем-разница-между-методами-GET-и-POST)
+ [32. Что такое MIME-тип?](#32-Что-такое-MIME-тип)
+ [33. Назовите преимущества Servlet над CGI?](#33-Назовите-преимущества-Servlet-над-CGI)
+ [34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?](#34-Каковы-наиболее-распространенные-задачи-выполняются-в-Servlet-контейнере)
+ [35. В чем разница между PrintWriter и ServletOutputStream?](#35-В-чем-разница-между-PrintWriter-и-ServletOutputStream)
+ [36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?](#36-Можем-ли-мы-получить-PrintWriter-и-ServletOutputStream-одновременно-в-сервлете)
+ [37. Расскажите о интерфейсе SingleThreadModel.](#37-Расскажите-о-интерфейсе-SingleThreadModel)
+ [38. Какие существуют атрибуты у сервлетов и какая сфера их применения?](#38-Какие-существуют-атрибуты-у-сервлетов-и-какая-сфера-их-применения)
+ [39. Почему необходимо переопределить только init метод без аргументов?](#39-Почему-необходимо-переопределить-только-init-метод-без-аргументов)
+ [40. Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode и decode?](#40-Что-означает-URL-encoding-Зачем-нужны-методы-javanetURLEncoderencode-и-decode)
+ [41. Зачем нужны и чем отличаются методы encodeUrl и encodeRedirectUrl?](#41-Зачем-нужны-и-чем-отличаются-методы-encodeUrl-и-encodeRedirectUrl)
+ [42. Какие различные методы управления сессией в сервлетах вы знаете?](#42-Какие-различные-методы-управления-сессией-в-сервлетах-вы-знаете)
+ [43. Что означает URL Rewriting?](#43-Что-означает-URL-Rewriting)
+ [44. Как применяются Cookies в сервлетах?](#44-Как-применяются-Cookies-в-сервлетах)
+ [45. Как уведомить объект в сессии, что сессия недействительна или закончилась?](#45-Как-уведомить-объект-в-сессии-что-сессия-недействительна-или-закончилась)
+ [46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?](#46-Какой-существует-эффективный-способ-удостоверится-что-все-сервлеты-доступны-только-для-пользователя-с-валидной-сессией)
+ [47. Как мы можем обеспечить transport layer security для нашего веб приложения?](#47-Как-мы-можем-обеспечить-transport-layer-security-для-нашего-веб-приложения)
+ [48. Как организовать подключение к базе дынных и обеспечить логирование log4j в сервлете?](#48-Как-организовать-подключение-к-базе-дынных-и-обеспечить-логирование-log4j-в-сервлете)
+ [49. Какие важные особенности существуют в Servlet 3?](#49-Какие-важные-особенности-существуют-в-Servlet-3)
+ [50. Каковы различные способы аутентификации сервлета?](#50-Каковы-различные-способы-аутентификации-сервлета)
+ [51. Написать сервлет, реализующий загрузку файла на сервер.](#51-Написать-сервлет-реализующий-загрузку-файла-на-сервер)


## 1 Что такое сервлет

Сервлет является интерфейсом Java, реализация которого расширяет функциональные возможности сервера. 
Сервлет взаимодействует с клиентами посредством принципа запрос-ответ.
Хотя сервлеты могут обслуживать любые запросы, они обычно используются для расширения веб-серверов. 
Для таких приложений технология Java Servlet определяет HTTP-специфичные сервлет классы. 
Пакеты javax.servlet и javax.servlet.http обеспечивают интерфейсы и классы для создания сервлетов.

[к оглавлению](#Servlet)

## 2 Какова структура веб проекта

| Path | Description |
| --- | --- |
| src/main/java| Application/Library sources |
| src/main/resources| Application/Library resources |
| src/main/filters| Resource filter files |
| src/main/webapp| Web application sources |
| src/test/java| Test sources |
| src/test/resources| Test resources |
| src/test/filters| Test resource filter files |
| src/it| Integration Tests (primarily for plugins) |
| src/assembly| Assembly descriptors |
| src/site| Site |
| LICENSE.txt| Project’s license |
| NOTICE.txt| Notices and attributions required by libraries that the project depends on |
| README.txt| Project’s readme |

[http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html](http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html)

[к оглавлению](#Servlet)

## 3 Что такое контейнер сервлетов

**Контейнер сервлетов**  — программа, представляющая собой сервер, 
который занимается системной поддержкой сервлетов и обеспечивает их жизненный цикл 
в соответствии с правилами, определёнными в спецификациях.

Известные реализации:Apache Tomcat, Jetty, JBoss, GlassFish, IBM WebSphere, Oracle Weblogic.

[к оглавлению](#Servlet)

## 4 Каковы задачи функциональность контейнера сервлетов

Контейнер сервлетов может работать как полноценный самостоятельный веб-сервер, 
быть поставщиком страниц для другого веб-сервера, например Apache, или интегрироваться в Java EE сервер приложений. 
Обеспечивает обмен данными между сервлетом и клиентами, берёт на себя выполнение таких функций, 
как создание программной среды для функционирующего сервлета, идентификацию и авторизацию клиентов, 
организацию сессии для каждого из них.

[к оглавлению](#Servlet)

## 5 Что вы знаете о сервлет фильтрах

Сервлетный фильтр, в соответствии со спецификацией, это Java-код, пригодный для повторного использования 
и позволяющий преобразовать содержание HTTP-запросов, HTTP-ответов и информацию, содержащуюся в заголовках HTTP. 
Сервлетный фильтр занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, 
и/или последующей обработкой ответа, исходящего из сервлета.Сервлетные фильтры могут:

+ перехватывать инициализацию сервлета прежде, чем сервлет будет инициирован;
+ определить содержание запроса прежде, чем сервлет будет инициирован;
+ модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
+ модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ;
+ перехватывать инициализацию сервлета после обращения к сервлету.

Сервлетный фильтр может быть сконфигурирован так, что он будет работать с одним сервлетом или группой сервлетов. 
Основой для формирования фильтров служит интерфейс javax.servlet.Filter, который реализует три метода:
+ void init (FilterConfig config) throws ServletException;
+ void destroy();
+ void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;

Метод init() вызывается прежде, чем фильтр начинает работать,и настраивает конфигурационный объект фильтра. 
Метод doFilter выполняет непосредственно работу фильтра. 
Таким образом, сервер вызывает init() один раз, чтобы запустить фильтр в работу, 
а затем вызывает doFilter() столько раз, сколько запросов будет сделано непосредственно к данному фильтру. 
После того, как фильтр заканчивает свою работу, вызывается метод destroy().

[Java Servlet Filter Example Tutorial:](https://www.journaldev.com/1933/java-servlet-filter-example-tutorial)

[к оглавлению](#Servlet)

## 6 Зачем нужны слушатели в сервлетах

Слушатели контекста и сессий — это классы, которые могут следить за тем, 
когда контекст или сессия были инициализированы, или отслеживать время, когда они должны быть уничтожены, 
и когда атрибуты были добавлены или удалены из контекста или сессии. 
Servlet 2.4 расширяет модель слушателей запроса, позволяя отслеживать, как запрос создается и уничтожается, 
и, как атрибуты добавляются и удаляются из сервлета 
В Servlet 2.4 добавлены следующие классы:

+ ServletRequestListener
+ ServletRequestEvent
+ ServletRequestAttributeListener
+ ServletRequestAttributeEvent

[к оглавлению](#Servlet)

## 7 Когда вы будете использовать фильтры а когда слушатели

[Servlet Listener Example](http://www.journaldev.com/1945/servlet-listener-example-servletcontextlistener-httpsessionlistener-and-servletrequestlistener)

[к оглавлению](#Servlet)

## 8 Как обработать исключения выброшенные другим сервлетом в приложении

Т.к. браузер понимает только HTTP, то когда приложение выбросит исключение контейнер сервлетов обработает исключение и создаст HTTP response. 
Это аналогично тому что происходит при кодах ошибок вроде 404, 403 и т.д. 
Servlet API предоставляет поддержку собственных сервлетов для обработки исключений и ошибок, 
которые мы можем задать в дескрипторе развертывания. 
Главная задача таких сервлетов — обработать ошибку или исключение и отправить понятный HTTP ответ пользователю. 
Например, можно предоставить ссылку на главную страницу, а так же описание некоторых деталей об ошибке.

```java
    <error-page>
        <error-code>404</error-code>
        <location>/AppExceptionHandler</location>
    </error-page>
 
    <error-page>
        <exception-type>javax.servlet.ServletException</exception-type>
        <location>/AppExceptionHandler</location>
    </error-page>
```

[Servlet Exception and Error Handling Example Tutoria](http://www.journaldev.com/1973/servlet-exception-and-error-handling-example-tutorial)

[к оглавлению](#Servlet)

## 9 Что такое дескриптор развертывания

Дескриптор развертывания — это конфигурационный файл артефакта, который будет развернут в контейнере сервлетов. 
В спецификации Java Platform, Enterprise Edition дескриптор развертывания описывает то, как компонент, 
модуль или приложение (такое, как веб-приложение или приложение предприятия) должно быть развернуто.

Этот конфигурационный файл указывает параметры развертывания для модуля или приложения с определенными настройками, 
параметры безопасности и описывает конкретные требования к конфигурации. 
Для синтаксиса файлов дескриптора развертывания используется язык XML.

[Настройка и описание web.xml в приложении с Spring и JSF](http://javastudy.ru/jsf-2/description-settings-web-xml-with-spring/)

[к оглавлению](#Servlet)

## 10 Как реализовать запуск сервлета с запуском приложения

Контейнер сервлетов обычно загружает сервлет при первом запросе клиента, 
но иногда необходимо загрузить сервлет прямо на старте приложения (например если сервлет объемный и будет долго грузиться). 
Для этого необходимо использовать элемент load-on-startup в дескрипторе (или аннотацию loadOnStartup), 
который укажет необходимость загрузки сервлета при запуске.

```java
<servlet>
    <servlet-name>foo</servlet-name>
    <servlet-class>com.foo.servlets.Foo</servlet-class>
    <load-on-startup>5</load-on-startup>
</servlet>
```

Значение должно быть int. Если значение отрицательное, то сервлет будет загружен при запросе клиента, 
а если 0 и далее, то загрузится на старте приложения. Чем меньше число, тем раньше в очереди на загрузку будет сервлет.

[к оглавлению](#Servlet)

## 11 Что представляет собой объект ServletConfig

Интерфейс javax.servlet.ServletConfig используется для передачи конфигурационной информации сервлету. 
Каждый сервлет имеет свой собственный объект ServletConfig, за создание экземпляра которого ответственен контейнер сервлетов. 
Для установки параметров конфигурации используются init параметры в web.xml (или аннотации WebInitParam). 
Для получения объекта ServletConfig данного сервлета используется метод getServletConfig().

[к оглавлению](#Servlet)

## 12 Что представляет собой объект ServletContext

Интерфейс javax.servlet.ServletContext предоставляет доступ к параметрам веб приложения сервлету. 
Объект ServletContext является уникальным и доступен всем сервлетам веб приложения. 
Мы можем использовать объект ServletContext, когда нам необходимо предоставить доступ одному или нескольким сервлетам к инициализированным параметрам веб приложения. 
Для этого используется элемент <context-param> в web.xml. 
Объект ServletContext можно получить с помощью метода getServletContext() у интерфейса ServletConfig.
Контейнеры сервлетов так же могут предоставлять context объекты, уникальные для группы сервлетов. 
Каждая из групп будет связана со своим набором URL путей хоста.
ServletContext был расширен в спецификации Servlet 3 и предоставляет программное добавление слушателей и фильтров в приложение. 
Так же у этого интерфейса имеются множество полезных методов вроде getMimeType(), getResourceAsStream() и т.д..

[к оглавлению](#Servlet)

## 13 В чем отличия ServletContext и ServletConfig

+ ServletConfig является уникальным объектом для каждого сервлета, в то время как ServletContext уникальный для всего приложения.
+ ServletConfig используется для предоставления параметров инициализации сервлету, а ServletContext для предоставления параметров инициализации приложения для всех сервлетов.
+ У нас нет возможности устанавливать атрибуты в объекте ServletConfig, в то время как можно установить атрибуты в объекте ServletContext, которые будут доступны другим сервлетам.

[к оглавлению](#Servlet)

## 14 Что такое Request Dispatcher

Интерфейс RequestDispatcher используется для передачи запроса другому ресурсу 
(это может быть HTML, JSP или другой сервлет в том же приложении). 
Мы можем использовать это для добавления контента другого ресурса к ответу. 
Этот интерфейс используется для внутренней коммуникации между сервлетами в одном контексте. 
В интерфейсе реализовано два метода:
+ void forward(ServletRequest var1, ServletResponse var2) — передает запрос из сервлета к другому ресурсу (сервлету, JSP или HTML файлу) на сервере.
+ void include(ServletRequest var1, ServletResponse var2) — включает контент ресурса (сервлет, JSP или HTML страница) в ответ.

Доступ к интерфейсу можно получить с помощью метода ServletContext getRequestDispatcher(String s). 
Путь должен начинаться с / , который будет интерпретироваться относительным текущего корневого пути контекста.

[к оглавлению](#Servlet)

## 15 Как можно создать блокировку deadlock в сервлете

Дедлок можно получить реализовав зацикленный вызов метода, например вызвав метод doPost() в методе doGet() и вызвать doGet() в методе doPost().

[к оглавлению](#Servlet)

## 16 Как получить адрес сервлета на сервере

Для получения актуального пути сервлета на сервере можно использовать эту конструкцию: 

```java
getServletContext().getRealPath(request.getServletPath())
```

[к оглавлению](#Servlet)

## 17 Как получить информацию о сервере из сервлета

Информацию о сервере можно получить с использованием объекта ServletContext с помощью метода getServerInfo(). 
```java
getServletContext().getServerInfo().
```

[к оглавлению](#Servlet)

## 18 Как получить ip адрес клиента на сервере

Использовать request.getRemoteAddr() для получения ip клиента в сервлете.

[к оглавлению](#Servlet)

## 19 Что вы знаете о классах обертках wrapper для сервлетов

В Servlet HTTP API предоставляются два класса обертки — HttpServletRequestWrapper и HttpServletResponseWrapper. 
Они помогают разработчикам реализовывать собственные реализации типов request и response сервлета. 
Мы можем расширить эти классы и переопределить только необходимые методы для реализации собственных типов объектов ответов и запросов. 
Эти классы не используются в стандартном программировании сервлетов.

[к оглавлению](#Servlet)

## 20 Каков жизненный цикл сервлета и когда какие методы вызываются

Контейнер сервлетов управляет четырьмя фазами жизненного цикла сервлета:

+ Загрузка класса сервлета — когда контейнер получает запрос для сервлета, то происходит загрузка класса сервлета в память и вызов конструктора без параметров.
+ Инициализация класса сервлета — после того как класс загружен контейнер инициализирует объект ServletConfig 
для этого сервлета и внедряет его через init() метод. Это и есть место где сервлет класс преобразуется из обычного класса в сервлет.
+ Обработка запросов — после инициализации сервлет готов к обработке запросов. 
Для каждого запроса клиента сервлет контейнер порождает новую нить (поток) и вызывает метод service() путем передачи ссылки на объект ответа и запроса.
+ Удаление из Service — когда контейнер останавливается или останавливается приложение, 
то контейнер сервлетов уничтожает классы сервлетов путем вызова destroy() метода.

Можно описать как последовательность вызова методов: init(), service(), destroy().

+ public void init(ServletConfig config) – используется контейнером для инициализации сервлета. Вызывается один раз за время жизни сервлета.
+ public void service(ServletRequest request, ServletResponse response) – вызывается для каждого запроса. Метод не может быть вызван раньше выполнения init() метода.
+ public void destroy() – вызывается для уничтожения сервлета (один раз за время жизни сервлета).

[к оглавлению](#Servlet)

## 21 Какие методы необходимо определить при создании сервлетов

Чтобы создать сервлет, необходимо описать сервлет с помощью:

```java
<servlet-mapping> 
  <servlet-name>MyOwnDefaultServlet</servlet-name>
  <url-pattern>/myservlet/*</url-pattern>
</servlet-mapping>
 
<servlet>
  <servlet-name>HelloWorld2</servlet-name> 
  <servlet-class>examples.servlets.HelloWorld2</servlet-class>
   <init-param>
    <param-name>greeting</param-name> 
    <param-value>Welcome</param-value> 
  </init-param>
   <init-param>
    <param-name>person</param-name> 
    <param-value>WebLogic Developer</param-value> 
  </init-param>
</servlet>
```

Затем расширить класс сервлета от класса HttpServlet.
Реализовать метод service() или doGet(), doPost() (или первый или вторые).

[к оглавлению](#Servlet)

## 22 В каком случае вы будете переопределять метод service

Метод service() переопределяется, когда мы хотим, чтобы сервлет обрабатывал как GET так и POST запросы в одном методе. 
Когда контейнер сервлетов получает запрос клиента, то происходит вызов метода service(), 
который в свою очередь вызывает doGet(), doPost() методы, основанные на HTTP методе запроса. 
Есть мнение, что метод service() переопределять особого смысла нет, 
кроме указанного вначале случая использования одного метода на два типа запросов.

[к оглавлению](#Servlet)

## 23 Есть ли смысл определить конструктор для сервлета как лучше инициализировать данные

Такая возможность есть, но считается бессмысленной. 
Инициализировать данные лучше переопределив метод init(), 
в котором получить доступ к параметрам инициализации сервлета через использование объекта ServletConfig.

[к оглавлению](#Servlet)

## 24 В чем отличия GenericServlet и HttpServlet

Абстрактный класс GenericServlet — независимая от используемого протокола реализация интерфейса Servlet. 
HttpServlet, как понятно из название, реализация интерфейса сервлета для протокола HTTP. 
Следует отметить, что HttpServlet extends GenericServlet.

[к оглавлению](#Servlet)

## 25 Как вызвать из сервлета другой сервлет этого же и другого приложения

Если необходимо вызывать сервлет из того же приложения, 
то необходимо использовать механизм внутренней коммуникации сервлетов (inter-servlet communication mechanisms). 
Мы можем вызвать другой сервлет с помощью RequestDispatcher forward() и include() методов 
для доступа к дополнительным атрибутам в запросе для использования в другом сервлете. 
+ Метод forward() используется для передачи обработки запроса в другой сервлет. 
+ Метод include() используется, если мы хотим вложить результат работы другого сервлета в возвращаемый ответ.

Если необходимо вызывать сервлет из другого приложения, 
то использовать RequestDispatcher уже не получится (определен для приложения). 
Поэтому можно использовать ServletResponse sendRedirect() метод и предоставить полный URL из другого сервлета. 
Для передачи данных можно использовать cookies как часть ответа сервлета, а потом использовать их в нашем сервлете.

[к оглавлению](#Servlet)

## 26 Что вы знаете и в чем отличия методов forward и sendRedirect

RequestDispatcher forward() используется для проброски того же самого запроса к другому ресурсу, 
в то время как ServletResponse sendRedirect() это двухшаговый метод. 
Во втором методе веб приложение возвращает ответ клиенту с status code 302 (redirect) с ссылкой для отправки запроса. 
Запрос посылает полностью новый запрос.
forward() обрабатывается внутри контейнера, а sendRedirect() обрабатывается браузером.
Необходимо использовать forward() для организации доступа внутри одного и того же приложения, 
т.к. он быстрее sendRedirect(), которому требуется дополнительная сетевая работа.
В методе forward() браузер не знает о фактически обрабатываемом ресурсе и URL в строке остается прежним. 
В sendRedirect() методе URL адрес изменяется на пробрасываемый ресурс.
В методе forward() нельзя использовать для внедрения сервлета в другой контекст. Для этого можно использовать только sendRedirect().

[к оглавлению](#Servlet)

## 27 Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами

Методы класса HTTPServlet init() и destroy() вызываются один раз за жизненный цикл сервлета — поэтому по поводу них беспокоиться не стоит. 
Методы doGet(), doPost() вызываются на каждый запрос клиента и т.к. сервлеты используют многопоточность, 
то здесь нужно задумываться о потокобезопасной работе.

В случае наличия локальных переменных в этих методах нет необходимости думать о многопоточной безопасности, 
т.к. они будут созданы отдельно для каждой нити. 
Но если используются глобальные ресурсы, то необходимо использовать синхронизацию как и в любом многопоточном приложении Java.

[к оглавлению](#Servlet)

## 28 В чем отличие между веб сервером и сервером приложений

Веб сервер необходим для обработки HTTP request от браузера клиента и ответа клиенту с помощью HTTP response. 
Веб сервер понимает язык HTTP и запускается по HTTP протоколу. 
Примером веб сервера может служить реализация от Apache — Tomcat.

Сервер приложений предоставляет дополнительные возможности, 
такие как поддержка JavaBeans, JMS Messaging, Transaction Management и др. 
Можно сказать, что сервер приложений — это веб сервер с дополнительными возможностями, 
которые помогают разрабатывать корпоративные приложения.

[к оглавлению](#Servlet)

## 29 Какой метод HTTP не является неизменяемым

HTTP метод называется неизменяемым, если он всегда возвращает одинаковый результат. 
HTTP методы GET, PUT, DELETE, HEAD, OPTIONS являются неизменяемыми. 
Необходимо реализовывать приложение так, чтобы эти методы возвращали одинаковый результат. 
К изменяемым методам относится HTTP метод POST. Post метод используется для реализации чего-либо, что изменяется при каждом запросе.

К примеру, для доступа к HTML странице или изображению необходимо использовать метод GET, т.к. он возвращает одинаковый результат. 
Но если нам необходимо сохранить информацию о заказе в базе данных, то нужно использовать POST метод. 
Неизменяемые методы так же известны как безопасные методы и нет необходимости заботиться о повторяющихся запросах от клиента для этих методов.

[к оглавлению](#Servlet)

## 30 Почему HttpServlet класс объявлен как абстрактный

Класс HTTPServlet предоставляет реализацию HTTP протокола сервлета 
(а следовательно помогает избежать постоянного кодинга повторяющейся информации), 
но он не имеет реализованных методов doGet() и doPost() (у них по умолчанию возвращение HTTP 405 Method Not Implemented error), 
а следовательно объявлен абстрактным. Реализация этих методов перекладывается на разработчика.

[к оглавлению](#Servlet)

## 31 В чем разница между методами GET и POST

+ GET метод является неизменяемым, тогда как POST — изменяемый.
+ С помощью метода GET можно посылать ограниченное кол-во данных, которые будут пересланы в заголовке URL. 
В случае POST метода мы можем пересылать большие объемы данных, т.к. они будут находится в теле метода.
+ Данные GET метода передаются в открытом виде, что может использоваться в зловредных целях. 
POST данные передаются в теле запроса и скрыты от пользователя.
+ GET метод является HTTP методом по умолчанию, а POST метод необходимо указывать явно, чтобы отправить запрос.
+ GET метод используется гиперссылками на странице.

[к оглавлению](#Servlet)

## 32 Что такое MIME тип

MIME (произн. «майм», англ. Multipurpose Internet Mail Extensions — многоцелевые расширения интернет-почты) — стандарт, 
описывающий передачу различных типов данных по электронной почте, а также, в общем случае, 
спецификация для кодирования информации и форматирования сообщений таким образом, чтобы их можно было пересылать по Интернету. 
Content-Type response header это и есть MIME тип. 
Сервер посылает MIME тип клиенту для того, чтобы он понял какой тип данных пересылается. 
Это помогает верно отобразить полученные данные на клиенте. 
Наиболее часто используемые MIME типы: text/html, text/xml, application/xml и многие др.

В ServletContext существует метод getMimeType() для получения корректного MIME типа файла 
и дальнейшего использования этой информации для указания типа контента в ответе.

[к оглавлению](#Servlet)

## 33 Назовите преимущества Servlet над CGI

Технология сервлетов была создана для преодоления недостатков Common Gateway Interface (общий интерфейс шлюза). 
Можно выделить следующие преимущества сервлетов над CGI:

+ Сервлеты предоставляют лучшую производительность в условиях обработки запросов, 
лучшее использование памяти за счет использования преимущество многопоточности 
(на каждый запрос создается новая нить, что быстрее выделения памяти под новый объект для каждого запроса, как это происходит в CGI).
+ Сервлеты, платформа и система являются независимыми. 
Таким образом веб приложение написанное с использованием сервлетов может быть запущена в любом контейнере сервлетов, 
реализующим стандарт и в любой операционной системе.
+ Использование сервлетов повышает надежность программы, 
т.к. контейнер сервлетов самостоятельно заботится о жизненном цикле сервлетов (а значит и за утечками памяти), 
безопасности и сборщике мусора.
+ Сервлеты относительно легки в изучении и поддержке, таким образом разработчику необходимо заботиться только о бизнес логике приложения, 
а не внутренней реализации веб технологий.

[к оглавлению](#Servlet)

## 34 Каковы наиболее распространенные задачи выполняются в Servlet контейнере

+ Поддержка обмена данными. Контейнер сервлетов предоставляет легкий способ обмена данными между веб клиентом (браузером) и сервлетом. 
Благодаря контейнеру нет необходимости создавать слушателя сокета на сервере для отслеживания запросов от клиента, 
а так же разбирать запрос и генерировать ответ. 
Все эти важные и комплексные задачи решаются с помощью контейнера и разработчик может сосредоточиться на бизнес логике приложения.
+ Управление жизненным циклом сервлетов и ресурсов. Начиная от загрузки сервлета в память, инициализации, внедрения методов и заканчивая уничтожением сервлета. 
Контейнер так же предоставляет дополнительные утилиты, например JNDI, для управления пулом ресурсов.
+ Поддержка многопоточности. Контейнер самостоятельно создает новую нить для каждого запроса и предоставляет ей запрос и ответ для обработки. 
Таким образом сервлет не инициализируется заново для каждого запроса и тем самым сохраняет память и уменьшает время до обработки запроса.
+ Поддержка JSP. JSP классы не похожи на стандартные классы джавы, но контейнер сервлетов преобразует каждую JSP в сервлет и далее управляется контейнером как обычным сервлетом.
+ Различные задачи. Контейнер сервлетов управляет пулом ресурсов, памятью приложения, сборщиком мусора. Предоставляются возможности настройки безопасности и многое другое.

[к оглавлению](#Servlet)

## 35 В чем разница между PrintWriter и ServletOutputStream

PrintWriter — это класс для работы с символьным потоком, а ServletOutputStream — класс для работы байтовым потоком. 
PrintWriter используется для записи информации на основе символов, вроде массива символов или строки в ответ, 
в то время как ServletOutputStream используется для записи в ответ массива байтов. 
Для получения экземпляра ServletOutputStream используется метод ServletResponse getOutputStream(), 
а для PrintWriter — метод ServletResponse getWriter().

[к оглавлению](#Servlet)

## 36 Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете

Мы не можем создать два объекта этих классов в одном сервлете. 
При попытке внедрить оба метода getWriter() и getOutputStream() в ответе, 
мы получим исключение java.lang.IllegalStateException с сообщением, что уже другой метод был вызван для этого ответа.

[к оглавлению](#Servlet)

## 37 Расскажите о интерфейсе SingleThreadModel

Интерфейс был создан, чтобы гарантировать потокобезопасность и невозможности создания двух нитей в сервис методе сервлета. 
Однако интерфейс SingleThreadModel не решает всех проблем потокобезопасности. 
Например, атрибуты сессии или статические переменные могут быть доступны различным запросам в различных потоках в одно и тоже время 
(даже при использовании этого интерфейса). В общем это убило весь профит от многопоточности и интерфейс объявлен deprecated начиная с Servlet 2.4.

[к оглавлению](#Servlet)

## 38 Какие существуют атрибуты у сервлетов и какая сфера их применения

Атрибуты сервлетов ипользуются для внутренней коммуникации сервлетов. 
Мы можем использовать атрибуты set, get, remove в веб приложении. 
Существует три области видимости атрибутов — request scope, session scope, application scope.

Интерфейсы ServletRequest, HttpSession и ServletContext предоставляют методы для get(), set(), remove() атрибутов из request scope, 
session scope, application scope соответственно.

[к оглавлению](#Servlet)

## 39 Почему необходимо переопределить только init метод без аргументов

Если нам необходимо инициализировать какие-то ресурсы до того как сервлет начнет обрабатывать запросы, то необходимо переопределить метод init(). 
Если переопределить метод init(ServletConfig config), то первым должен быть вызван метод super(config), 
который обеспечит вызов метода init(ServletConfig config) суперкласса. 
Именно поэтому GenericServlet предоставляет другой метод init() без параметров, 
который будет вызываться в конце метода init(ServletConfig config). 
Разработчик должен использовать переопределенный метод init() без параметров для инициализации переменных для избежания каких-либо проблем, 
например не указав вызов super() в переопределенном методе init(ServletConfig config).

[к оглавлению](#Servlet)

## 40 Что означает URL encoding Зачем нужны методы javanetURLEncoderencode и decode

URL Encoding — процесс преобразования данных в форму CGI (Common Gateway Interface), 
который позволит путешествовать по сети без проблем. 
URL Encoding разделяет пробелы и заменяет специальные символы с помощью escape-симолов. 
Например, для кодирования строки используется метод  java.net.URLEncoder.encode(String str, String unicode). 
Обратная операция декодирования возможна благодаря методу java.net.URLDecoder.decode(String str, String unicode). 
Пример работы метода: строка «Java for study .ru» будет преобразована в Java%20for%20study%20.ru.

[к оглавлению](#Servlet)

## 41 Зачем нужны и чем отличаются методы encodeUrl и encodeRedirectUrl

HttpServletResponse предоставляет методы преобразования URL в HTML гиперссылки с преобразованием спец символов и пробелов, 
а так же добавления session id к URL. Такое поведение аналогично URLEncoder encode(), но с добавлением дополнительного параметра jsessionid в конец URL.

Метод HttpServletResponse encodeRedirectUrl() применяется для преобразования redirect URL в ответе. 
Таким образом при предоставлении поддержки URL rewriting для HTML гиперссылок необходимо использовать encodeURL(), 
а для редирект URL’ов использовать encodeRedirectUrl().

[к оглавлению](#Servlet)

## 42 Какие различные методы управления сессией в сервлетах вы знаете

Сессия является обычным состоянием взаимодействия сервера и клиента и может содержать в себе множество запросов и ответов клиент-сервер. 
Т.к. HTTP и веб сервер не запоминают состояния (stateless), 
то единственным способом поддерживать сессию является пересылка уникальной информации (session id) в каждом запросе и ответе между клиентом и сервером.

Существуют несколько распространенных способов управления сессией в сервлетах:

+ Аутентификация пользователя
+ HTML hidden field (скрытое поле)
+ Cookies
+ URL Rewriting
+ Session Management API

[Java Servlet Session Management Tutorial with Examples of Cookies, HttpSession and URL Rewriting](http://www.journaldev.com/1907/java-servlet-session-management-tutorial-with-examples-of-cookies-httpsession-and-url-rewriting)

[к оглавлению](#Servlet)

## 43 Что означает URL Rewriting

Для управления сессией в сервлетах мы можем использовать HTTPSession, но он работает с Cookies, а их иногда отключают. 
Для этого случая в сервлетах предусмотрена возможность URL Rewriting. 
С точки зрения программирования необходимо всего одно действие — кодирование URL. 
Другим достоинством является то, что этот метод является как бы запасным и включается только при выключенных куках.

Применяя метод HttpServletResponse encodeURL() мы можем закодировать URL. Если необходим редирект к другому ресурсу, 
то для предоставления информации о сессии применяется метод encodeRedirectURL().

[к оглавлению](#Servlet)

## 44 Как применяются Cookies в сервлетах

Cookies (куки) используются в клиент-серверном взаимодействии и они не являются чем-то конкретным к Java. 
Servlet API предоставляет поддержку cookies через класс javax.servlet.http.Cookie implements Serializable, Cloneable. 
Для получения массива cookies из запроса необходимо воспользоваться методом HttpServletRequest getCookies(). 
Для добавления cookies в запрос методов не предусмотрено.

Аналогично HttpServletResponse addCookie(Cookie c) — может добавить cookie в response header, но не существует геттера для этого типа передачи данных.

[Servlet Cookie Example Tutorial](http://www.journaldev.com/1956/servlet-cookie-example-tutorial)

[к оглавлению](#Servlet)

## 45 Как уведомить объект в сессии что сессия недействительна или закончилась

Чтобы быть уверенным об оповещение объекта о прекращении сессии, 
объект должен реализовывать интерфейс javax.servlet.http.HttpSessionBindingListener. 
Два метода этого интерфейса: valueBound() и valueUnbound() применяются для реализации логики при добавлении объекта в качестве атрибута к сессии и при уничтожения сессии.

[Servlet Listener Example – ServletContextListener, HttpSessionListener and ServletRequestListener](http://www.journaldev.com/1945/servlet-listener-example-servletcontextlistener-httpsessionlistener-and-servletrequestlistener)

[к оглавлению](#Servlet)

## 46 Какой существует эффективный способ удостоверится что все сервлеты доступны только для пользователя с валидной сессией

Сервлет фильтры используются для перехвата всех запросов между контейнером сервлетов и сервлетом. 
Поэтому логично использовать фильтр для проверки необходимой информации (например валидности сессии) в запросе.

[к оглавлению](#Servlet)

## 47 Как мы можем обеспечить transport layer security для нашего веб приложения

Для этого необходимо настроить SSL для вашего сервлет контейнера. 
Как это сделать описано в мануалах для конкретной реализации контейнера.

[к оглавлению](#Servlet)

## 48 Как организовать подключение к базе дынных и обеспечить логирование log4j в сервлете

При работе с большим количеством подключений к базе данных рекомендуется инициализировать их в servlet context listener 
и установить в качестве атрибута контекста для возможности использования другими сервлетами. 
Логирование Log4j подключается с помощью конфигурации XML (или файла property) и далее эта информация используется при конфигурировании context listener’а.

[Servlet Example in Java with Database Connection and Log4j integration](http://www.journaldev.com/1997/servlet-example-in-java-with-database-connection-and-log4j-integration)

[к оглавлению](#Servlet)

## 49 Какие важные особенности существуют в Servlet 3

+ Servlet Annotations. До Servlet 3 весь маппинг был в web.xml, что приводило к ошибкам и банально неудобно при большом количестве сервлетов. Примеры аннотаций:  @WebServlet, @WebInitParam, @WebFilter, @WebListener.
+ Web Fragments. С появлением веб фрагментов мы можем содержать множество модулей в одностраничном веб приложении. Все модули прописываются в fragment.xml в META-INF директории. Это позволяет разделять веб приложение на отдельные модули, включенные как JAR файлы в отдельной lib директории.
+ Динамическое добавление веб компонентов. Используя ServletContext объект, мы можем программно добавлять фильтры и слушатели. Это помогает построить динамическую систему, в которой необходимый объект будет вызван только по необходимости. Для этого применяются методы addServlet(), addFilter(), addListener().
+ Асинхронное выполнение. Поддержка асинхронной обработки позволяет передать выполнение запроса в другой поток без удержания всего сервера занятым.

[Асинхронный сервлет](http://www.journaldev.com/2008/async-servlet-feature-of-servlet-3)

[к оглавлению](#Servlet)

## 50 Каковы различные способы аутентификации сервлета

Контейнер сервлетов предоставляет различные способы аутентификации:

+ HTTP Basic Authentication
+ HTTP Digest Authentication
+ HTTPS Authentication
+ Form Based Login

[к оглавлению](#Servlet)

## 51 Написать сервлет реализующий загрузку файла на сервер

[Servlet Upload File and Download File Example](http://www.journaldev.com/1964/servlet-upload-file-and-download-file-example)

[к оглавлению](#Servlet)